
image.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000078  00800100  00000f1c  00000fb0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f1c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000006e  00800178  00800178  00001028  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00001028  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000171  00000000  00000000  00001068  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000ebe  00000000  00000000  000011d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000004ab  00000000  00000000  00002097  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000ba7  00000000  00000000  00002542  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000130  00000000  00000000  000030ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003df  00000000  00000000  0000321c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004da  00000000  00000000  000035fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000d8  00000000  00000000  00003ad5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 01 	jmp	0x270	; 0x270 <__ctors_end>
   4:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
   8:	0c 94 f3 05 	jmp	0xbe6	; 0xbe6 <__vector_2>
   c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  10:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  14:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  18:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  1c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  20:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  24:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  28:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  2c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  30:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  34:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  38:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  3c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  40:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  44:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  48:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  4c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  50:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  54:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  58:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  5c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  60:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  64:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  68:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  6c:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  70:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  74:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>
  78:	0c 94 55 01 	jmp	0x2aa	; 0x2aa <__bad_interrupt>

0000007c <font5x7>:
  7c:	00 00 00 00 00 00 00 5f 00 00 00 03 00 03 00 14     ......._........
  8c:	3e 14 3e 14 24 2a 7f 2a 12 43 33 08 66 61 36 49     >.>.$*.*.C3.fa6I
  9c:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
  ac:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
  bc:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
  cc:	3e 51 49 45 3e 00 04 02 7f 00 42 61 51 49 46 22     >QIE>.....BaQIF"
  dc:	41 49 49 36 18 14 12 7f 10 27 45 45 45 39 3e 49     AII6.....'EEE9>I
  ec:	49 49 32 01 01 71 09 07 36 49 49 49 36 26 49 49     II2..q..6III6&II
  fc:	49 3e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     I>.66...V6...."A
 10c:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
 11c:	3e 41 59 55 5e 7e 09 09 09 7e 7f 49 49 49 36 3e     >AYU^~...~.III6>
 12c:	41 41 41 22 7f 41 41 41 3e 7f 49 49 49 41 7f 09     AAA".AAA>.IIIA..
 13c:	09 09 01 3e 41 41 49 3a 7f 08 08 08 7f 00 41 7f     ...>AAI:......A.
 14c:	41 00 30 40 40 40 3f 7f 08 14 22 41 7f 40 40 40     A.0@@@?..."A.@@@
 15c:	40 7f 02 0c 02 7f 7f 02 04 08 7f 3e 41 41 41 3e     @..........>AAA>
 16c:	7f 09 09 09 06 1e 21 21 21 5e 7f 09 09 09 76 26     ......!!!^....v&
 17c:	49 49 49 32 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III2.....?@@@?. 
 18c:	40 20 1f 7f 20 10 20 7f 41 22 1c 22 41 07 08 70     @ .. . .A"."A..p
 19c:	08 07 61 51 49 45 43 00 7f 41 00 00 02 04 08 10     ..aQIEC..A......
 1ac:	20 00 00 41 7f 00 04 02 01 02 04 40 40 40 40 40      ..A.......@@@@@
 1bc:	00 01 02 04 00 20 54 54 54 78 7f 44 44 44 38 38     ..... TTTx.DDD88
 1cc:	44 44 44 44 38 44 44 44 7f 38 54 54 54 18 04 04     DDDD8DDD.8TTT...
 1dc:	7e 05 05 08 54 54 54 3c 7f 08 04 04 78 00 44 7d     ~...TTT<....x.D}
 1ec:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
 1fc:	00 7c 04 78 04 78 7c 08 04 04 78 38 44 44 44 38     .|.x.x|...x8DDD8
 20c:	7c 14 14 14 08 08 14 14 14 7c 00 7c 08 04 04 48     |........|.|...H
 21c:	54 54 54 20 04 04 3f 44 44 3c 40 40 20 7c 1c 20     TTT ..?DD<@@ |. 
 22c:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
 23c:	50 3c 44 64 54 4c 44 00 08 36 41 41 00 00 7f 00     P<DdTLD..6AA....
 24c:	00 41 41 36 08 00 02 01 02 04 02                    .AA6.......

00000257 <init_cmds>:
 257:	d6 80 01 82 f4 a4 23 c6 2c 94 ab c2 81 ca f7 c4     ......#.,.......
 267:	70 98 00 c8 00 e0 81 82 00                          p........

00000270 <__ctors_end>:
 270:	11 24       	eor	r1, r1
 272:	1f be       	out	0x3f, r1	; 63
 274:	cf ef       	ldi	r28, 0xFF	; 255
 276:	d0 e1       	ldi	r29, 0x10	; 16
 278:	de bf       	out	0x3e, r29	; 62
 27a:	cd bf       	out	0x3d, r28	; 61

0000027c <__do_copy_data>:
 27c:	11 e0       	ldi	r17, 0x01	; 1
 27e:	a0 e0       	ldi	r26, 0x00	; 0
 280:	b1 e0       	ldi	r27, 0x01	; 1
 282:	ec e1       	ldi	r30, 0x1C	; 28
 284:	ff e0       	ldi	r31, 0x0F	; 15
 286:	02 c0       	rjmp	.+4      	; 0x28c <.do_copy_data_start>

00000288 <.do_copy_data_loop>:
 288:	05 90       	lpm	r0, Z+
 28a:	0d 92       	st	X+, r0

0000028c <.do_copy_data_start>:
 28c:	a8 37       	cpi	r26, 0x78	; 120
 28e:	b1 07       	cpc	r27, r17
 290:	d9 f7       	brne	.-10     	; 0x288 <.do_copy_data_loop>

00000292 <__do_clear_bss>:
 292:	11 e0       	ldi	r17, 0x01	; 1
 294:	a8 e7       	ldi	r26, 0x78	; 120
 296:	b1 e0       	ldi	r27, 0x01	; 1
 298:	01 c0       	rjmp	.+2      	; 0x29c <.do_clear_bss_start>

0000029a <.do_clear_bss_loop>:
 29a:	1d 92       	st	X+, r1

0000029c <.do_clear_bss_start>:
 29c:	a6 3e       	cpi	r26, 0xE6	; 230
 29e:	b1 07       	cpc	r27, r17
 2a0:	e1 f7       	brne	.-8      	; 0x29a <.do_clear_bss_loop>
 2a2:	0e 94 3a 05 	call	0xa74	; 0xa74 <main>
 2a6:	0c 94 8c 07 	jmp	0xf18	; 0xf18 <_exit>

000002aa <__bad_interrupt>:
 2aa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002ae <init_display_controller>:
#include "ili934x.h"

void init_display_controller()
{
	uint16_t x, y;
	RESET_lo();
 2ae:	12 98       	cbi	0x02, 2	; 2
 2b0:	88 ee       	ldi	r24, 0xE8	; 232
 2b2:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 2b4:	2c e2       	ldi	r18, 0x2C	; 44
 2b6:	31 e0       	ldi	r19, 0x01	; 1
 2b8:	f9 01       	movw	r30, r18
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	f1 f7       	brne	.-4      	; 0x2ba <init_display_controller+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2be:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2c0:	d9 f7       	brne	.-10     	; 0x2b8 <init_display_controller+0xa>
	_delay_ms(100);
	RESET_hi();
 2c2:	12 9a       	sbi	0x02, 2	; 2
 2c4:	88 ee       	ldi	r24, 0xE8	; 232
 2c6:	93 e0       	ldi	r25, 0x03	; 3
 2c8:	2c e2       	ldi	r18, 0x2C	; 44
 2ca:	31 e0       	ldi	r19, 0x01	; 1
 2cc:	f9 01       	movw	r30, r18
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <init_display_controller+0x20>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 2d2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 2d4:	d9 f7       	brne	.-10     	; 0x2cc <init_display_controller+0x1e>
	_delay_ms(100);
	RS_hi();
 2d6:	14 9a       	sbi	0x02, 4	; 2
	WR_hi();
 2d8:	13 9a       	sbi	0x02, 3	; 2
	RD_hi(); 
 2da:	15 9a       	sbi	0x02, 5	; 2
	CS_lo();
 2dc:	10 98       	cbi	0x02, 0	; 2
	BLC_lo();
 2de:	11 98       	cbi	0x02, 1	; 2
	VSYNC_hi();
 2e0:	16 9a       	sbi	0x02, 6	; 2
	write_cmd(DISPLAY_OFF);
 2e2:	14 98       	cbi	0x02, 4	; 2
 2e4:	88 e2       	ldi	r24, 0x28	; 40
 2e6:	88 b9       	out	0x08, r24	; 8
 2e8:	13 98       	cbi	0x02, 3	; 2
 2ea:	13 9a       	sbi	0x02, 3	; 2
 2ec:	14 9a       	sbi	0x02, 4	; 2
	write_cmd(SLEEP_OUT);
 2ee:	14 98       	cbi	0x02, 4	; 2
 2f0:	81 e1       	ldi	r24, 0x11	; 17
 2f2:	88 b9       	out	0x08, r24	; 8
 2f4:	13 98       	cbi	0x02, 3	; 2
 2f6:	13 9a       	sbi	0x02, 3	; 2
 2f8:	14 9a       	sbi	0x02, 4	; 2
 2fa:	88 e5       	ldi	r24, 0x58	; 88
 2fc:	92 e0       	ldi	r25, 0x02	; 2
 2fe:	2c e2       	ldi	r18, 0x2C	; 44
 300:	31 e0       	ldi	r19, 0x01	; 1
 302:	f9 01       	movw	r30, r18
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	f1 f7       	brne	.-4      	; 0x304 <init_display_controller+0x56>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 308:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 30a:	d9 f7       	brne	.-10     	; 0x302 <init_display_controller+0x54>
	_delay_ms(60);
	write_cmd_data(INTERNAL_IC_SETTING,			 1, "\x01");
 30c:	14 98       	cbi	0x02, 4	; 2
 30e:	8b ec       	ldi	r24, 0xCB	; 203
 310:	88 b9       	out	0x08, r24	; 8
 312:	13 98       	cbi	0x02, 3	; 2
 314:	13 9a       	sbi	0x02, 3	; 2
 316:	14 9a       	sbi	0x02, 4	; 2
 318:	81 e0       	ldi	r24, 0x01	; 1
 31a:	88 b9       	out	0x08, r24	; 8
 31c:	13 98       	cbi	0x02, 3	; 2
 31e:	13 9a       	sbi	0x02, 3	; 2
	write_cmd_data(POWER_CONTROL_1,				 2, "\x26\x08");
 320:	14 98       	cbi	0x02, 4	; 2
 322:	80 ec       	ldi	r24, 0xC0	; 192
 324:	88 b9       	out	0x08, r24	; 8
 326:	13 98       	cbi	0x02, 3	; 2
 328:	13 9a       	sbi	0x02, 3	; 2
 32a:	14 9a       	sbi	0x02, 4	; 2
 32c:	86 e2       	ldi	r24, 0x26	; 38
 32e:	88 b9       	out	0x08, r24	; 8
 330:	13 98       	cbi	0x02, 3	; 2
 332:	13 9a       	sbi	0x02, 3	; 2
 334:	88 e0       	ldi	r24, 0x08	; 8
 336:	88 b9       	out	0x08, r24	; 8
 338:	13 98       	cbi	0x02, 3	; 2
 33a:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(POWER_CONTROL_2,				 1, "\x10");
 33c:	14 98       	cbi	0x02, 4	; 2
 33e:	81 ec       	ldi	r24, 0xC1	; 193
 340:	88 b9       	out	0x08, r24	; 8
 342:	13 98       	cbi	0x02, 3	; 2
 344:	13 9a       	sbi	0x02, 3	; 2
 346:	14 9a       	sbi	0x02, 4	; 2
 348:	80 e1       	ldi	r24, 0x10	; 16
 34a:	88 b9       	out	0x08, r24	; 8
 34c:	13 98       	cbi	0x02, 3	; 2
 34e:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(VCOM_CONTROL_1,				 2, "\x35\x3E");
 350:	14 98       	cbi	0x02, 4	; 2
 352:	85 ec       	ldi	r24, 0xC5	; 197
 354:	88 b9       	out	0x08, r24	; 8
 356:	13 98       	cbi	0x02, 3	; 2
 358:	13 9a       	sbi	0x02, 3	; 2
 35a:	14 9a       	sbi	0x02, 4	; 2
 35c:	85 e3       	ldi	r24, 0x35	; 53
 35e:	88 b9       	out	0x08, r24	; 8
 360:	13 98       	cbi	0x02, 3	; 2
 362:	13 9a       	sbi	0x02, 3	; 2
 364:	8e e3       	ldi	r24, 0x3E	; 62
 366:	88 b9       	out	0x08, r24	; 8
 368:	13 98       	cbi	0x02, 3	; 2
 36a:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(MEMORY_ACCESS_CONTROL,		 1, "\x48");
 36c:	14 98       	cbi	0x02, 4	; 2
 36e:	86 e3       	ldi	r24, 0x36	; 54
 370:	88 b9       	out	0x08, r24	; 8
 372:	13 98       	cbi	0x02, 3	; 2
 374:	13 9a       	sbi	0x02, 3	; 2
 376:	14 9a       	sbi	0x02, 4	; 2
 378:	88 e4       	ldi	r24, 0x48	; 72
 37a:	88 b9       	out	0x08, r24	; 8
 37c:	13 98       	cbi	0x02, 3	; 2
 37e:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(RGB_INTERFACE_SIGNAL_CONTROL, 1, "\x4A");  // Set the DE/Hsync/Vsync/Dotclk polarity
 380:	14 98       	cbi	0x02, 4	; 2
 382:	80 eb       	ldi	r24, 0xB0	; 176
 384:	88 b9       	out	0x08, r24	; 8
 386:	13 98       	cbi	0x02, 3	; 2
 388:	13 9a       	sbi	0x02, 3	; 2
 38a:	14 9a       	sbi	0x02, 4	; 2
 38c:	8a e4       	ldi	r24, 0x4A	; 74
 38e:	88 b9       	out	0x08, r24	; 8
 390:	13 98       	cbi	0x02, 3	; 2
 392:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(FRAME_CONTROL_IN_NORMAL_MODE, 2, "\x00\x1B"); // 70Hz
 394:	14 98       	cbi	0x02, 4	; 2
 396:	81 eb       	ldi	r24, 0xB1	; 177
 398:	88 b9       	out	0x08, r24	; 8
 39a:	13 98       	cbi	0x02, 3	; 2
 39c:	13 9a       	sbi	0x02, 3	; 2
 39e:	14 9a       	sbi	0x02, 4	; 2
 3a0:	18 b8       	out	0x08, r1	; 8
 3a2:	13 98       	cbi	0x02, 3	; 2
 3a4:	13 9a       	sbi	0x02, 3	; 2
 3a6:	8b e1       	ldi	r24, 0x1B	; 27
 3a8:	88 b9       	out	0x08, r24	; 8
 3aa:	13 98       	cbi	0x02, 3	; 2
 3ac:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(DISPLAY_FUNCTION_CONTROL,	 4, "\x0A\x82\x27\x00");
 3ae:	14 98       	cbi	0x02, 4	; 2
 3b0:	86 eb       	ldi	r24, 0xB6	; 182
 3b2:	88 b9       	out	0x08, r24	; 8
 3b4:	13 98       	cbi	0x02, 3	; 2
 3b6:	13 9a       	sbi	0x02, 3	; 2
 3b8:	14 9a       	sbi	0x02, 4	; 2
 3ba:	ee e2       	ldi	r30, 0x2E	; 46
 3bc:	f1 e0       	ldi	r31, 0x01	; 1
 3be:	81 91       	ld	r24, Z+
 3c0:	88 b9       	out	0x08, r24	; 8
 3c2:	13 98       	cbi	0x02, 3	; 2
 3c4:	13 9a       	sbi	0x02, 3	; 2
 3c6:	41 e0       	ldi	r20, 0x01	; 1
 3c8:	e2 33       	cpi	r30, 0x32	; 50
 3ca:	f4 07       	cpc	r31, r20
 3cc:	c1 f7       	brne	.-16     	; 0x3be <init_display_controller+0x110>
    write_cmd_data(VCOM_CONTROL_2,			     1, "\xB5");
 3ce:	14 98       	cbi	0x02, 4	; 2
 3d0:	87 ec       	ldi	r24, 0xC7	; 199
 3d2:	88 b9       	out	0x08, r24	; 8
 3d4:	13 98       	cbi	0x02, 3	; 2
 3d6:	13 9a       	sbi	0x02, 3	; 2
 3d8:	14 9a       	sbi	0x02, 4	; 2
 3da:	85 eb       	ldi	r24, 0xB5	; 181
 3dc:	88 b9       	out	0x08, r24	; 8
 3de:	13 98       	cbi	0x02, 3	; 2
 3e0:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(INTERFACE_CONTROL,			 3, "\x01\x00\x00"); // System interface
 3e2:	14 98       	cbi	0x02, 4	; 2
 3e4:	86 ef       	ldi	r24, 0xF6	; 246
 3e6:	88 b9       	out	0x08, r24	; 8
 3e8:	13 98       	cbi	0x02, 3	; 2
 3ea:	13 9a       	sbi	0x02, 3	; 2
 3ec:	14 9a       	sbi	0x02, 4	; 2
 3ee:	ea e2       	ldi	r30, 0x2A	; 42
 3f0:	f1 e0       	ldi	r31, 0x01	; 1
 3f2:	81 91       	ld	r24, Z+
 3f4:	88 b9       	out	0x08, r24	; 8
 3f6:	13 98       	cbi	0x02, 3	; 2
 3f8:	13 9a       	sbi	0x02, 3	; 2
 3fa:	81 e0       	ldi	r24, 0x01	; 1
 3fc:	ed 32       	cpi	r30, 0x2D	; 45
 3fe:	f8 07       	cpc	r31, r24
 400:	c1 f7       	brne	.-16     	; 0x3f2 <init_display_controller+0x144>
    write_cmd_data(GAMMA_DISABLE,				 1, "\x00"); 
 402:	14 98       	cbi	0x02, 4	; 2
 404:	82 ef       	ldi	r24, 0xF2	; 242
 406:	88 b9       	out	0x08, r24	; 8
 408:	13 98       	cbi	0x02, 3	; 2
 40a:	13 9a       	sbi	0x02, 3	; 2
 40c:	14 9a       	sbi	0x02, 4	; 2
 40e:	18 b8       	out	0x08, r1	; 8
 410:	13 98       	cbi	0x02, 3	; 2
 412:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(GAMMA_SET,					 1, "\x01"); // Select Gamma curve 1
 414:	14 98       	cbi	0x02, 4	; 2
 416:	86 e2       	ldi	r24, 0x26	; 38
 418:	88 b9       	out	0x08, r24	; 8
 41a:	13 98       	cbi	0x02, 3	; 2
 41c:	13 9a       	sbi	0x02, 3	; 2
 41e:	14 9a       	sbi	0x02, 4	; 2
 420:	81 e0       	ldi	r24, 0x01	; 1
 422:	88 b9       	out	0x08, r24	; 8
 424:	13 98       	cbi	0x02, 3	; 2
 426:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(PIXEL_FORMAT_SET,			 1, "\x55"); // 0x66 - 18bit /pixel,  0x55 - 16bit/pixel
 428:	14 98       	cbi	0x02, 4	; 2
 42a:	8a e3       	ldi	r24, 0x3A	; 58
 42c:	88 b9       	out	0x08, r24	; 8
 42e:	13 98       	cbi	0x02, 3	; 2
 430:	13 9a       	sbi	0x02, 3	; 2
 432:	14 9a       	sbi	0x02, 4	; 2
 434:	85 e5       	ldi	r24, 0x55	; 85
 436:	88 b9       	out	0x08, r24	; 8
 438:	13 98       	cbi	0x02, 3	; 2
 43a:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(POSITIVE_GAMMA_CORRECTION,	15, "\x1F\x1A\x18\x0A\x0F\x06\x45\x87\x32\x0A\x07\x02\x07\x05\x00");
 43c:	14 98       	cbi	0x02, 4	; 2
 43e:	80 ee       	ldi	r24, 0xE0	; 224
 440:	88 b9       	out	0x08, r24	; 8
 442:	13 98       	cbi	0x02, 3	; 2
 444:	13 9a       	sbi	0x02, 3	; 2
 446:	14 9a       	sbi	0x02, 4	; 2
 448:	ea e1       	ldi	r30, 0x1A	; 26
 44a:	f1 e0       	ldi	r31, 0x01	; 1
 44c:	81 91       	ld	r24, Z+
 44e:	88 b9       	out	0x08, r24	; 8
 450:	13 98       	cbi	0x02, 3	; 2
 452:	13 9a       	sbi	0x02, 3	; 2
 454:	41 e0       	ldi	r20, 0x01	; 1
 456:	e9 32       	cpi	r30, 0x29	; 41
 458:	f4 07       	cpc	r31, r20
 45a:	c1 f7       	brne	.-16     	; 0x44c <init_display_controller+0x19e>
    write_cmd_data(NEGATIVE_GAMMA_CORRECTION,	15, "\x00\x25\x27\x05\x10\x09\x3A\x78\x4D\x05\x18\x0D\x38\x3A\x1F");
 45c:	14 98       	cbi	0x02, 4	; 2
 45e:	81 ee       	ldi	r24, 0xE1	; 225
 460:	88 b9       	out	0x08, r24	; 8
 462:	13 98       	cbi	0x02, 3	; 2
 464:	13 9a       	sbi	0x02, 3	; 2
 466:	14 9a       	sbi	0x02, 4	; 2
 468:	ea e0       	ldi	r30, 0x0A	; 10
 46a:	f1 e0       	ldi	r31, 0x01	; 1
 46c:	81 91       	ld	r24, Z+
 46e:	88 b9       	out	0x08, r24	; 8
 470:	13 98       	cbi	0x02, 3	; 2
 472:	13 9a       	sbi	0x02, 3	; 2
 474:	81 e0       	ldi	r24, 0x01	; 1
 476:	e9 31       	cpi	r30, 0x19	; 25
 478:	f8 07       	cpc	r31, r24
 47a:	c1 f7       	brne	.-16     	; 0x46c <init_display_controller+0x1be>
    write_cmd_data(COLUMN_ADDRESS_SET,			 4, "\x00\x00\x00\xEF");
 47c:	14 98       	cbi	0x02, 4	; 2
 47e:	8a e2       	ldi	r24, 0x2A	; 42
 480:	88 b9       	out	0x08, r24	; 8
 482:	13 98       	cbi	0x02, 3	; 2
 484:	13 9a       	sbi	0x02, 3	; 2
 486:	14 9a       	sbi	0x02, 4	; 2
 488:	e5 e0       	ldi	r30, 0x05	; 5
 48a:	f1 e0       	ldi	r31, 0x01	; 1
 48c:	81 91       	ld	r24, Z+
 48e:	88 b9       	out	0x08, r24	; 8
 490:	13 98       	cbi	0x02, 3	; 2
 492:	13 9a       	sbi	0x02, 3	; 2
 494:	41 e0       	ldi	r20, 0x01	; 1
 496:	e9 30       	cpi	r30, 0x09	; 9
 498:	f4 07       	cpc	r31, r20
 49a:	c1 f7       	brne	.-16     	; 0x48c <init_display_controller+0x1de>
    write_cmd_data(PAGE_ADDRESS_SET,			 4, "\x00\x00\x01\x3F");
 49c:	14 98       	cbi	0x02, 4	; 2
 49e:	8b e2       	ldi	r24, 0x2B	; 43
 4a0:	88 b9       	out	0x08, r24	; 8
 4a2:	13 98       	cbi	0x02, 3	; 2
 4a4:	13 9a       	sbi	0x02, 3	; 2
 4a6:	14 9a       	sbi	0x02, 4	; 2
 4a8:	e0 e0       	ldi	r30, 0x00	; 0
 4aa:	f1 e0       	ldi	r31, 0x01	; 1
 4ac:	81 91       	ld	r24, Z+
 4ae:	88 b9       	out	0x08, r24	; 8
 4b0:	13 98       	cbi	0x02, 3	; 2
 4b2:	13 9a       	sbi	0x02, 3	; 2
 4b4:	81 e0       	ldi	r24, 0x01	; 1
 4b6:	e4 30       	cpi	r30, 0x04	; 4
 4b8:	f8 07       	cpc	r31, r24
 4ba:	c1 f7       	brne	.-16     	; 0x4ac <init_display_controller+0x1fe>
    write_cmd(TEARING_EFFECT_LINE_OFF);
 4bc:	14 98       	cbi	0x02, 4	; 2
 4be:	84 e3       	ldi	r24, 0x34	; 52
 4c0:	88 b9       	out	0x08, r24	; 8
 4c2:	13 98       	cbi	0x02, 3	; 2
 4c4:	13 9a       	sbi	0x02, 3	; 2
 4c6:	14 9a       	sbi	0x02, 4	; 2
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
 4c8:	14 98       	cbi	0x02, 4	; 2
 4ca:	84 eb       	ldi	r24, 0xB4	; 180
 4cc:	88 b9       	out	0x08, r24	; 8
 4ce:	13 98       	cbi	0x02, 3	; 2
 4d0:	13 9a       	sbi	0x02, 3	; 2
 4d2:	14 9a       	sbi	0x02, 4	; 2
 4d4:	18 b8       	out	0x08, r1	; 8
 4d6:	13 98       	cbi	0x02, 3	; 2
 4d8:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
 4da:	14 98       	cbi	0x02, 4	; 2
 4dc:	87 eb       	ldi	r24, 0xB7	; 183
 4de:	88 b9       	out	0x08, r24	; 8
 4e0:	13 98       	cbi	0x02, 3	; 2
 4e2:	13 9a       	sbi	0x02, 3	; 2
 4e4:	14 9a       	sbi	0x02, 4	; 2
 4e6:	87 e0       	ldi	r24, 0x07	; 7
 4e8:	88 b9       	out	0x08, r24	; 8
 4ea:	13 98       	cbi	0x02, 3	; 2
 4ec:	13 9a       	sbi	0x02, 3	; 2
    /* Clear display */
	write_cmd(MEMORY_WRITE);
 4ee:	14 98       	cbi	0x02, 4	; 2
 4f0:	8c e2       	ldi	r24, 0x2C	; 44
 4f2:	88 b9       	out	0x08, r24	; 8
 4f4:	13 98       	cbi	0x02, 3	; 2
 4f6:	13 9a       	sbi	0x02, 3	; 2
 4f8:	14 9a       	sbi	0x02, 4	; 2
 4fa:	20 e0       	ldi	r18, 0x00	; 0
 4fc:	30 e0       	ldi	r19, 0x00	; 0
 4fe:	10 c0       	rjmp	.+32     	; 0x520 <init_display_controller+0x272>
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
			write_data16(0x0000);
 500:	18 b8       	out	0x08, r1	; 8
 502:	13 98       	cbi	0x02, 3	; 2
 504:	13 9a       	sbi	0x02, 3	; 2
 506:	18 b8       	out	0x08, r1	; 8
 508:	13 98       	cbi	0x02, 3	; 2
 50a:	13 9a       	sbi	0x02, 3	; 2
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
    /* Clear display */
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
		for(y=0; y<320; y++)
 50c:	01 96       	adiw	r24, 0x01	; 1
 50e:	41 e0       	ldi	r20, 0x01	; 1
 510:	80 34       	cpi	r24, 0x40	; 64
 512:	94 07       	cpc	r25, r20
 514:	a9 f7       	brne	.-22     	; 0x500 <init_display_controller+0x252>
    write_cmd(TEARING_EFFECT_LINE_OFF);
    write_cmd_data(DISPLAY_INVERSION_CONTROL,	 1, "\x00");
    write_cmd_data(ENTRY_MODE_SET,				 1, "\x07");
    /* Clear display */
	write_cmd(MEMORY_WRITE);
	for(x=0; x<240; x++)
 516:	2f 5f       	subi	r18, 0xFF	; 255
 518:	3f 4f       	sbci	r19, 0xFF	; 255
 51a:	20 3f       	cpi	r18, 0xF0	; 240
 51c:	31 05       	cpc	r19, r1
 51e:	19 f0       	breq	.+6      	; 0x526 <init_display_controller+0x278>
 520:	80 e0       	ldi	r24, 0x00	; 0
 522:	90 e0       	ldi	r25, 0x00	; 0
 524:	ed cf       	rjmp	.-38     	; 0x500 <init_display_controller+0x252>
		for(y=0; y<320; y++)
			write_data16(0x0000);
	write_cmd(DISPLAY_ON);
 526:	14 98       	cbi	0x02, 4	; 2
 528:	89 e2       	ldi	r24, 0x29	; 41
 52a:	88 b9       	out	0x08, r24	; 8
 52c:	13 98       	cbi	0x02, 3	; 2
 52e:	13 9a       	sbi	0x02, 3	; 2
 530:	14 9a       	sbi	0x02, 4	; 2
 532:	84 ef       	ldi	r24, 0xF4	; 244
 534:	91 e0       	ldi	r25, 0x01	; 1
 536:	2c e2       	ldi	r18, 0x2C	; 44
 538:	31 e0       	ldi	r19, 0x01	; 1
 53a:	f9 01       	movw	r30, r18
 53c:	31 97       	sbiw	r30, 0x01	; 1
 53e:	f1 f7       	brne	.-4      	; 0x53c <init_display_controller+0x28e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 540:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 542:	d9 f7       	brne	.-10     	; 0x53a <init_display_controller+0x28c>
	_delay_ms(50);
	BLC_hi();
 544:	11 9a       	sbi	0x02, 1	; 2
};
 546:	08 95       	ret

00000548 <init_lcd>:

void init_lcd()
{
	/* Disable JTAG in software, so that it does not interfere with Port C  */
	/* It will be re-enabled after a power cycle if the JTAGEN fuse is set. */
	MCUCR |= (1<<JTD);
 548:	85 b7       	in	r24, 0x35	; 53
 54a:	80 68       	ori	r24, 0x80	; 128
 54c:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1<<JTD);
 54e:	85 b7       	in	r24, 0x35	; 53
 550:	80 68       	ori	r24, 0x80	; 128
 552:	85 bf       	out	0x35, r24	; 53
	
	/* Configure ports */
	CTRL_DDR = 0x7F;
 554:	8f e7       	ldi	r24, 0x7F	; 127
 556:	81 b9       	out	0x01, r24	; 1
	DATA_DDR = 0xFF;
 558:	8f ef       	ldi	r24, 0xFF	; 255
 55a:	87 b9       	out	0x07, r24	; 7
	
	init_display_controller();
 55c:	0e 94 57 01 	call	0x2ae	; 0x2ae <init_display_controller>
}
 560:	08 95       	ret

00000562 <set_orientation>:

void set_orientation(orientation o)
{
 562:	9c 01       	movw	r18, r24
	display.orient = o;
 564:	90 93 6d 01 	sts	0x016D, r25
 568:	80 93 6c 01 	sts	0x016C, r24
	write_cmd(MEMORY_ACCESS_CONTROL);
 56c:	14 98       	cbi	0x02, 4	; 2
 56e:	86 e3       	ldi	r24, 0x36	; 54
 570:	88 b9       	out	0x08, r24	; 8
 572:	13 98       	cbi	0x02, 3	; 2
 574:	13 9a       	sbi	0x02, 3	; 2
 576:	14 9a       	sbi	0x02, 4	; 2
	if (o==North) { 
 578:	21 15       	cp	r18, r1
 57a:	31 05       	cpc	r19, r1
 57c:	71 f4       	brne	.+28     	; 0x59a <set_orientation+0x38>
		display.width = LCDWIDTH;
 57e:	80 ef       	ldi	r24, 0xF0	; 240
 580:	90 e0       	ldi	r25, 0x00	; 0
 582:	90 93 69 01 	sts	0x0169, r25
 586:	80 93 68 01 	sts	0x0168, r24
		display.height = LCDHEIGHT;
 58a:	80 e4       	ldi	r24, 0x40	; 64
 58c:	91 e0       	ldi	r25, 0x01	; 1
 58e:	90 93 6b 01 	sts	0x016B, r25
 592:	80 93 6a 01 	sts	0x016A, r24
		write_data(0x48);
 596:	88 e4       	ldi	r24, 0x48	; 72
 598:	32 c0       	rjmp	.+100    	; 0x5fe <set_orientation+0x9c>
	}
	else if (o==West) {
 59a:	21 30       	cpi	r18, 0x01	; 1
 59c:	31 05       	cpc	r19, r1
 59e:	71 f4       	brne	.+28     	; 0x5bc <set_orientation+0x5a>
		display.width = LCDHEIGHT;
 5a0:	80 e4       	ldi	r24, 0x40	; 64
 5a2:	91 e0       	ldi	r25, 0x01	; 1
 5a4:	90 93 69 01 	sts	0x0169, r25
 5a8:	80 93 68 01 	sts	0x0168, r24
		display.height = LCDWIDTH;
 5ac:	80 ef       	ldi	r24, 0xF0	; 240
 5ae:	90 e0       	ldi	r25, 0x00	; 0
 5b0:	90 93 6b 01 	sts	0x016B, r25
 5b4:	80 93 6a 01 	sts	0x016A, r24
		write_data(0xE8);
 5b8:	88 ee       	ldi	r24, 0xE8	; 232
 5ba:	21 c0       	rjmp	.+66     	; 0x5fe <set_orientation+0x9c>
	}
	else if (o==South) {
 5bc:	22 30       	cpi	r18, 0x02	; 2
 5be:	31 05       	cpc	r19, r1
 5c0:	71 f4       	brne	.+28     	; 0x5de <set_orientation+0x7c>
		display.width = LCDWIDTH;
 5c2:	80 ef       	ldi	r24, 0xF0	; 240
 5c4:	90 e0       	ldi	r25, 0x00	; 0
 5c6:	90 93 69 01 	sts	0x0169, r25
 5ca:	80 93 68 01 	sts	0x0168, r24
		display.height = LCDHEIGHT;
 5ce:	80 e4       	ldi	r24, 0x40	; 64
 5d0:	91 e0       	ldi	r25, 0x01	; 1
 5d2:	90 93 6b 01 	sts	0x016B, r25
 5d6:	80 93 6a 01 	sts	0x016A, r24
		write_data(0x88);
 5da:	88 e8       	ldi	r24, 0x88	; 136
 5dc:	10 c0       	rjmp	.+32     	; 0x5fe <set_orientation+0x9c>
	}
	else if (o==East) {
 5de:	23 30       	cpi	r18, 0x03	; 3
 5e0:	31 05       	cpc	r19, r1
 5e2:	81 f4       	brne	.+32     	; 0x604 <set_orientation+0xa2>
		display.width = LCDHEIGHT;
 5e4:	80 e4       	ldi	r24, 0x40	; 64
 5e6:	91 e0       	ldi	r25, 0x01	; 1
 5e8:	90 93 69 01 	sts	0x0169, r25
 5ec:	80 93 68 01 	sts	0x0168, r24
		display.height = LCDWIDTH;
 5f0:	80 ef       	ldi	r24, 0xF0	; 240
 5f2:	90 e0       	ldi	r25, 0x00	; 0
 5f4:	90 93 6b 01 	sts	0x016B, r25
 5f8:	80 93 6a 01 	sts	0x016A, r24
		write_data(0x28);
 5fc:	88 e2       	ldi	r24, 0x28	; 40
 5fe:	88 b9       	out	0x08, r24	; 8
 600:	13 98       	cbi	0x02, 3	; 2
 602:	13 9a       	sbi	0x02, 3	; 2
	}
	write_cmd(COLUMN_ADDRESS_SET);
 604:	14 98       	cbi	0x02, 4	; 2
 606:	8a e2       	ldi	r24, 0x2A	; 42
 608:	88 b9       	out	0x08, r24	; 8
 60a:	13 98       	cbi	0x02, 3	; 2
 60c:	13 9a       	sbi	0x02, 3	; 2
 60e:	14 9a       	sbi	0x02, 4	; 2
	write_data16(0);
 610:	18 b8       	out	0x08, r1	; 8
 612:	13 98       	cbi	0x02, 3	; 2
 614:	13 9a       	sbi	0x02, 3	; 2
 616:	18 b8       	out	0x08, r1	; 8
 618:	13 98       	cbi	0x02, 3	; 2
 61a:	13 9a       	sbi	0x02, 3	; 2
	write_data16(display.width-1);
 61c:	80 91 68 01 	lds	r24, 0x0168
 620:	90 91 69 01 	lds	r25, 0x0169
 624:	01 97       	sbiw	r24, 0x01	; 1
 626:	98 b9       	out	0x08, r25	; 8
 628:	01 96       	adiw	r24, 0x01	; 1
 62a:	13 98       	cbi	0x02, 3	; 2
 62c:	13 9a       	sbi	0x02, 3	; 2
 62e:	81 50       	subi	r24, 0x01	; 1
 630:	88 b9       	out	0x08, r24	; 8
 632:	13 98       	cbi	0x02, 3	; 2
 634:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(PAGE_ADDRESS_SET);
 636:	14 98       	cbi	0x02, 4	; 2
 638:	8b e2       	ldi	r24, 0x2B	; 43
 63a:	88 b9       	out	0x08, r24	; 8
 63c:	13 98       	cbi	0x02, 3	; 2
 63e:	13 9a       	sbi	0x02, 3	; 2
 640:	14 9a       	sbi	0x02, 4	; 2
	write_data16(0);
 642:	18 b8       	out	0x08, r1	; 8
 644:	13 98       	cbi	0x02, 3	; 2
 646:	13 9a       	sbi	0x02, 3	; 2
 648:	18 b8       	out	0x08, r1	; 8
 64a:	13 98       	cbi	0x02, 3	; 2
 64c:	13 9a       	sbi	0x02, 3	; 2
	write_data16(display.height-1);
 64e:	80 91 6a 01 	lds	r24, 0x016A
 652:	90 91 6b 01 	lds	r25, 0x016B
 656:	01 97       	sbiw	r24, 0x01	; 1
 658:	98 b9       	out	0x08, r25	; 8
 65a:	01 96       	adiw	r24, 0x01	; 1
 65c:	13 98       	cbi	0x02, 3	; 2
 65e:	13 9a       	sbi	0x02, 3	; 2
 660:	81 50       	subi	r24, 0x01	; 1
 662:	88 b9       	out	0x08, r24	; 8
 664:	13 98       	cbi	0x02, 3	; 2
 666:	13 9a       	sbi	0x02, 3	; 2
}
 668:	08 95       	ret

0000066a <fill_rectangle>:

void fill_rectangle(rectangle r, uint16_t col)
{
 66a:	ef 92       	push	r14
 66c:	ff 92       	push	r15
 66e:	0f 93       	push	r16
 670:	1f 93       	push	r17
 672:	df 93       	push	r29
 674:	cf 93       	push	r28
 676:	cd b7       	in	r28, 0x3d	; 61
 678:	de b7       	in	r29, 0x3e	; 62
 67a:	28 97       	sbiw	r28, 0x08	; 8
 67c:	0f b6       	in	r0, 0x3f	; 63
 67e:	f8 94       	cli
 680:	de bf       	out	0x3e, r29	; 62
 682:	0f be       	out	0x3f, r0	; 63
 684:	cd bf       	out	0x3d, r28	; 61
 686:	f2 2f       	mov	r31, r18
 688:	29 83       	std	Y+1, r18	; 0x01
 68a:	e3 2f       	mov	r30, r19
 68c:	3a 83       	std	Y+2, r19	; 0x02
 68e:	4b 83       	std	Y+3, r20	; 0x03
 690:	5c 83       	std	Y+4, r21	; 0x04
 692:	36 2f       	mov	r19, r22
 694:	6d 83       	std	Y+5, r22	; 0x05
 696:	27 2f       	mov	r18, r23
 698:	7e 83       	std	Y+6, r23	; 0x06
 69a:	8f 83       	std	Y+7, r24	; 0x07
 69c:	98 87       	std	Y+8, r25	; 0x08
 69e:	78 01       	movw	r14, r16
 6a0:	ab 81       	ldd	r26, Y+3	; 0x03
 6a2:	bc 81       	ldd	r27, Y+4	; 0x04
 6a4:	06 2f       	mov	r16, r22
 6a6:	17 2f       	mov	r17, r23
 6a8:	6f 81       	ldd	r22, Y+7	; 0x07
 6aa:	78 85       	ldd	r23, Y+8	; 0x08
	uint16_t x, y;
	write_cmd(COLUMN_ADDRESS_SET);
 6ac:	14 98       	cbi	0x02, 4	; 2
 6ae:	8a e2       	ldi	r24, 0x2A	; 42
 6b0:	88 b9       	out	0x08, r24	; 8
 6b2:	13 98       	cbi	0x02, 3	; 2
 6b4:	13 9a       	sbi	0x02, 3	; 2
 6b6:	14 9a       	sbi	0x02, 4	; 2
	write_data16(r.left);
 6b8:	e8 b9       	out	0x08, r30	; 8
 6ba:	13 98       	cbi	0x02, 3	; 2
 6bc:	13 9a       	sbi	0x02, 3	; 2
 6be:	f8 b9       	out	0x08, r31	; 8
 6c0:	13 98       	cbi	0x02, 3	; 2
 6c2:	13 9a       	sbi	0x02, 3	; 2
	write_data16(r.right);
 6c4:	b8 b9       	out	0x08, r27	; 8
 6c6:	13 98       	cbi	0x02, 3	; 2
 6c8:	13 9a       	sbi	0x02, 3	; 2
 6ca:	a8 b9       	out	0x08, r26	; 8
 6cc:	13 98       	cbi	0x02, 3	; 2
 6ce:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(PAGE_ADDRESS_SET);
 6d0:	14 98       	cbi	0x02, 4	; 2
 6d2:	8b e2       	ldi	r24, 0x2B	; 43
 6d4:	88 b9       	out	0x08, r24	; 8
 6d6:	13 98       	cbi	0x02, 3	; 2
 6d8:	13 9a       	sbi	0x02, 3	; 2
 6da:	14 9a       	sbi	0x02, 4	; 2
	write_data16(r.top);
 6dc:	28 b9       	out	0x08, r18	; 8
 6de:	13 98       	cbi	0x02, 3	; 2
 6e0:	13 9a       	sbi	0x02, 3	; 2
 6e2:	38 b9       	out	0x08, r19	; 8
 6e4:	13 98       	cbi	0x02, 3	; 2
 6e6:	13 9a       	sbi	0x02, 3	; 2
	write_data16(r.bottom);
 6e8:	78 b9       	out	0x08, r23	; 8
 6ea:	13 98       	cbi	0x02, 3	; 2
 6ec:	13 9a       	sbi	0x02, 3	; 2
 6ee:	68 b9       	out	0x08, r22	; 8
 6f0:	13 98       	cbi	0x02, 3	; 2
 6f2:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(MEMORY_WRITE);
 6f4:	14 98       	cbi	0x02, 4	; 2
 6f6:	8c e2       	ldi	r24, 0x2C	; 44
 6f8:	88 b9       	out	0x08, r24	; 8
 6fa:	13 98       	cbi	0x02, 3	; 2
 6fc:	13 9a       	sbi	0x02, 3	; 2
 6fe:	14 9a       	sbi	0x02, 4	; 2
	for(x=r.left; x<=r.right; x++)
		for(y=r.top; y<=r.bottom; y++)
			write_data16(col);
 700:	2f 2f       	mov	r18, r31
 702:	3e 2f       	mov	r19, r30
 704:	c9 01       	movw	r24, r18
 706:	ac 01       	movw	r20, r24
 708:	0d c0       	rjmp	.+26     	; 0x724 <fill_rectangle+0xba>
	write_data16(r.right);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
 70a:	f8 b8       	out	0x08, r15	; 8
		for(y=r.top; y<=r.bottom; y++)
			write_data16(col);
 70c:	13 98       	cbi	0x02, 3	; 2
 70e:	13 9a       	sbi	0x02, 3	; 2
 710:	e8 b8       	out	0x08, r14	; 8
 712:	13 98       	cbi	0x02, 3	; 2
 714:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
		for(y=r.top; y<=r.bottom; y++)
 716:	2f 5f       	subi	r18, 0xFF	; 255
 718:	3f 4f       	sbci	r19, 0xFF	; 255
 71a:	62 17       	cp	r22, r18
 71c:	73 07       	cpc	r23, r19
 71e:	a8 f7       	brcc	.-22     	; 0x70a <fill_rectangle+0xa0>
	write_data16(r.right);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
 720:	4f 5f       	subi	r20, 0xFF	; 255
 722:	5f 4f       	sbci	r21, 0xFF	; 255
 724:	a4 17       	cp	r26, r20
 726:	b5 07       	cpc	r27, r21
 728:	10 f0       	brcs	.+4      	; 0x72e <fill_rectangle+0xc4>
 72a:	98 01       	movw	r18, r16
 72c:	f6 cf       	rjmp	.-20     	; 0x71a <fill_rectangle+0xb0>
		for(y=r.top; y<=r.bottom; y++)
			write_data16(col);
}
 72e:	28 96       	adiw	r28, 0x08	; 8
 730:	0f b6       	in	r0, 0x3f	; 63
 732:	f8 94       	cli
 734:	de bf       	out	0x3e, r29	; 62
 736:	0f be       	out	0x3f, r0	; 63
 738:	cd bf       	out	0x3d, r28	; 61
 73a:	cf 91       	pop	r28
 73c:	df 91       	pop	r29
 73e:	1f 91       	pop	r17
 740:	0f 91       	pop	r16
 742:	ff 90       	pop	r15
 744:	ef 90       	pop	r14
 746:	08 95       	ret

00000748 <fill_rectangle_indexed>:

void fill_rectangle_indexed(rectangle r, uint16_t* col)
{
 748:	ef 92       	push	r14
 74a:	ff 92       	push	r15
 74c:	0f 93       	push	r16
 74e:	1f 93       	push	r17
 750:	df 93       	push	r29
 752:	cf 93       	push	r28
 754:	cd b7       	in	r28, 0x3d	; 61
 756:	de b7       	in	r29, 0x3e	; 62
 758:	28 97       	sbiw	r28, 0x08	; 8
 75a:	0f b6       	in	r0, 0x3f	; 63
 75c:	f8 94       	cli
 75e:	de bf       	out	0x3e, r29	; 62
 760:	0f be       	out	0x3f, r0	; 63
 762:	cd bf       	out	0x3d, r28	; 61
 764:	f2 2f       	mov	r31, r18
 766:	29 83       	std	Y+1, r18	; 0x01
 768:	e3 2f       	mov	r30, r19
 76a:	3a 83       	std	Y+2, r19	; 0x02
 76c:	4b 83       	std	Y+3, r20	; 0x03
 76e:	5c 83       	std	Y+4, r21	; 0x04
 770:	36 2f       	mov	r19, r22
 772:	6d 83       	std	Y+5, r22	; 0x05
 774:	27 2f       	mov	r18, r23
 776:	7e 83       	std	Y+6, r23	; 0x06
 778:	8f 83       	std	Y+7, r24	; 0x07
 77a:	98 87       	std	Y+8, r25	; 0x08
 77c:	d8 01       	movw	r26, r16
 77e:	0b 81       	ldd	r16, Y+3	; 0x03
 780:	1c 81       	ldd	r17, Y+4	; 0x04
 782:	e6 2e       	mov	r14, r22
 784:	f7 2e       	mov	r15, r23
 786:	6f 81       	ldd	r22, Y+7	; 0x07
 788:	78 85       	ldd	r23, Y+8	; 0x08
	uint16_t x, y;
	write_cmd(COLUMN_ADDRESS_SET);
 78a:	14 98       	cbi	0x02, 4	; 2
 78c:	8a e2       	ldi	r24, 0x2A	; 42
 78e:	88 b9       	out	0x08, r24	; 8
 790:	13 98       	cbi	0x02, 3	; 2
 792:	13 9a       	sbi	0x02, 3	; 2
 794:	14 9a       	sbi	0x02, 4	; 2
	write_data16(r.left);
 796:	e8 b9       	out	0x08, r30	; 8
 798:	13 98       	cbi	0x02, 3	; 2
 79a:	13 9a       	sbi	0x02, 3	; 2
 79c:	f8 b9       	out	0x08, r31	; 8
 79e:	13 98       	cbi	0x02, 3	; 2
 7a0:	13 9a       	sbi	0x02, 3	; 2
	write_data16(r.right);
 7a2:	18 b9       	out	0x08, r17	; 8
 7a4:	13 98       	cbi	0x02, 3	; 2
 7a6:	13 9a       	sbi	0x02, 3	; 2
 7a8:	08 b9       	out	0x08, r16	; 8
 7aa:	13 98       	cbi	0x02, 3	; 2
 7ac:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(PAGE_ADDRESS_SET);
 7ae:	14 98       	cbi	0x02, 4	; 2
 7b0:	8b e2       	ldi	r24, 0x2B	; 43
 7b2:	88 b9       	out	0x08, r24	; 8
 7b4:	13 98       	cbi	0x02, 3	; 2
 7b6:	13 9a       	sbi	0x02, 3	; 2
 7b8:	14 9a       	sbi	0x02, 4	; 2
	write_data16(r.top);
 7ba:	28 b9       	out	0x08, r18	; 8
 7bc:	13 98       	cbi	0x02, 3	; 2
 7be:	13 9a       	sbi	0x02, 3	; 2
 7c0:	38 b9       	out	0x08, r19	; 8
 7c2:	13 98       	cbi	0x02, 3	; 2
 7c4:	13 9a       	sbi	0x02, 3	; 2
	write_data16(r.bottom);
 7c6:	78 b9       	out	0x08, r23	; 8
 7c8:	13 98       	cbi	0x02, 3	; 2
 7ca:	13 9a       	sbi	0x02, 3	; 2
 7cc:	68 b9       	out	0x08, r22	; 8
 7ce:	13 98       	cbi	0x02, 3	; 2
 7d0:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(MEMORY_WRITE);
 7d2:	14 98       	cbi	0x02, 4	; 2
 7d4:	8c e2       	ldi	r24, 0x2C	; 44
 7d6:	88 b9       	out	0x08, r24	; 8
 7d8:	13 98       	cbi	0x02, 3	; 2
 7da:	13 9a       	sbi	0x02, 3	; 2
 7dc:	14 9a       	sbi	0x02, 4	; 2
 7de:	2f 2f       	mov	r18, r31
 7e0:	3e 2f       	mov	r19, r30
 7e2:	c9 01       	movw	r24, r18
 7e4:	ac 01       	movw	r20, r24
 7e6:	14 c0       	rjmp	.+40     	; 0x810 <fill_rectangle_indexed+0xc8>
	for(x=r.left; x<=r.right; x++)
		for(y=r.top; y<=r.bottom; y++)
			write_data16(*col++);
 7e8:	11 96       	adiw	r26, 0x01	; 1
 7ea:	8c 91       	ld	r24, X
 7ec:	11 97       	sbiw	r26, 0x01	; 1
 7ee:	88 b9       	out	0x08, r24	; 8
 7f0:	13 98       	cbi	0x02, 3	; 2
 7f2:	13 9a       	sbi	0x02, 3	; 2
 7f4:	12 96       	adiw	r26, 0x02	; 2
 7f6:	8c 91       	ld	r24, X
 7f8:	12 97       	sbiw	r26, 0x02	; 2
 7fa:	88 b9       	out	0x08, r24	; 8
		for(y=r.top; y<=r.bottom; y++)
			write_data16(col);
}

void fill_rectangle_indexed(rectangle r, uint16_t* col)
{
 7fc:	14 96       	adiw	r26, 0x04	; 4
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
		for(y=r.top; y<=r.bottom; y++)
			write_data16(*col++);
 7fe:	13 98       	cbi	0x02, 3	; 2
 800:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
		for(y=r.top; y<=r.bottom; y++)
 802:	2f 5f       	subi	r18, 0xFF	; 255
 804:	3f 4f       	sbci	r19, 0xFF	; 255
 806:	62 17       	cp	r22, r18
 808:	73 07       	cpc	r23, r19
 80a:	70 f7       	brcc	.-36     	; 0x7e8 <fill_rectangle_indexed+0xa0>
	write_data16(r.right);
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(r.top);
	write_data16(r.bottom);
	write_cmd(MEMORY_WRITE);
	for(x=r.left; x<=r.right; x++)
 80c:	4f 5f       	subi	r20, 0xFF	; 255
 80e:	5f 4f       	sbci	r21, 0xFF	; 255
 810:	04 17       	cp	r16, r20
 812:	15 07       	cpc	r17, r21
 814:	10 f0       	brcs	.+4      	; 0x81a <fill_rectangle_indexed+0xd2>
 816:	97 01       	movw	r18, r14
 818:	f6 cf       	rjmp	.-20     	; 0x806 <fill_rectangle_indexed+0xbe>
		for(y=r.top; y<=r.bottom; y++)
			write_data16(*col++);
}
 81a:	28 96       	adiw	r28, 0x08	; 8
 81c:	0f b6       	in	r0, 0x3f	; 63
 81e:	f8 94       	cli
 820:	de bf       	out	0x3e, r29	; 62
 822:	0f be       	out	0x3f, r0	; 63
 824:	cd bf       	out	0x3d, r28	; 61
 826:	cf 91       	pop	r28
 828:	df 91       	pop	r29
 82a:	1f 91       	pop	r17
 82c:	0f 91       	pop	r16
 82e:	ff 90       	pop	r15
 830:	ef 90       	pop	r14
 832:	08 95       	ret

00000834 <clear_screen>:

void clear_screen()
{
 834:	0f 93       	push	r16
 836:	1f 93       	push	r17
 838:	df 93       	push	r29
 83a:	cf 93       	push	r28
 83c:	cd b7       	in	r28, 0x3d	; 61
 83e:	de b7       	in	r29, 0x3e	; 62
 840:	28 97       	sbiw	r28, 0x08	; 8
 842:	0f b6       	in	r0, 0x3f	; 63
 844:	f8 94       	cli
 846:	de bf       	out	0x3e, r29	; 62
 848:	0f be       	out	0x3f, r0	; 63
 84a:	cd bf       	out	0x3d, r28	; 61
	display.x = 0;
 84c:	10 92 6f 01 	sts	0x016F, r1
 850:	10 92 6e 01 	sts	0x016E, r1
	display.y = 0;
 854:	10 92 71 01 	sts	0x0171, r1
 858:	10 92 70 01 	sts	0x0170, r1
	rectangle r = {0, display.width-1, 0, display.height-1};
 85c:	20 91 68 01 	lds	r18, 0x0168
 860:	30 91 69 01 	lds	r19, 0x0169
 864:	21 50       	subi	r18, 0x01	; 1
 866:	30 40       	sbci	r19, 0x00	; 0
 868:	80 91 6a 01 	lds	r24, 0x016A
 86c:	90 91 6b 01 	lds	r25, 0x016B
 870:	01 97       	sbiw	r24, 0x01	; 1
 872:	1a 82       	std	Y+2, r1	; 0x02
 874:	19 82       	std	Y+1, r1	; 0x01
 876:	42 2f       	mov	r20, r18
 878:	3c 83       	std	Y+4, r19	; 0x04
 87a:	2b 83       	std	Y+3, r18	; 0x03
 87c:	1e 82       	std	Y+6, r1	; 0x06
 87e:	1d 82       	std	Y+5, r1	; 0x05
 880:	98 87       	std	Y+8, r25	; 0x08
 882:	8f 83       	std	Y+7, r24	; 0x07
	fill_rectangle(r, display.background);
 884:	00 91 74 01 	lds	r16, 0x0174
 888:	10 91 75 01 	lds	r17, 0x0175
 88c:	29 81       	ldd	r18, Y+1	; 0x01
 88e:	3a 81       	ldd	r19, Y+2	; 0x02
 890:	5c 81       	ldd	r21, Y+4	; 0x04
 892:	6d 81       	ldd	r22, Y+5	; 0x05
 894:	7e 81       	ldd	r23, Y+6	; 0x06
 896:	98 85       	ldd	r25, Y+8	; 0x08
 898:	0e 94 35 03 	call	0x66a	; 0x66a <fill_rectangle>
}
 89c:	28 96       	adiw	r28, 0x08	; 8
 89e:	0f b6       	in	r0, 0x3f	; 63
 8a0:	f8 94       	cli
 8a2:	de bf       	out	0x3e, r29	; 62
 8a4:	0f be       	out	0x3f, r0	; 63
 8a6:	cd bf       	out	0x3d, r28	; 61
 8a8:	cf 91       	pop	r28
 8aa:	df 91       	pop	r29
 8ac:	1f 91       	pop	r17
 8ae:	0f 91       	pop	r16
 8b0:	08 95       	ret

000008b2 <display_char>:

void display_char(char c)
{
 8b2:	6f 92       	push	r6
 8b4:	7f 92       	push	r7
 8b6:	8f 92       	push	r8
 8b8:	9f 92       	push	r9
 8ba:	af 92       	push	r10
 8bc:	bf 92       	push	r11
 8be:	cf 92       	push	r12
 8c0:	df 92       	push	r13
 8c2:	ef 92       	push	r14
 8c4:	ff 92       	push	r15
 8c6:	0f 93       	push	r16
 8c8:	1f 93       	push	r17
 8ca:	cf 93       	push	r28
 8cc:	df 93       	push	r29
 8ce:	98 2f       	mov	r25, r24
	uint16_t x, y;
	PGM_P fdata; 
	uint8_t bits, mask;
	uint16_t sc=display.x, ec=display.x + 4, sp=display.y, ep=display.y + 7;
 8d0:	00 91 6e 01 	lds	r16, 0x016E
 8d4:	10 91 6f 01 	lds	r17, 0x016F
 8d8:	24 e0       	ldi	r18, 0x04	; 4
 8da:	e2 2e       	mov	r14, r18
 8dc:	f1 2c       	mov	r15, r1
 8de:	e0 0e       	add	r14, r16
 8e0:	f1 1e       	adc	r15, r17
 8e2:	60 90 70 01 	lds	r6, 0x0170
 8e6:	70 90 71 01 	lds	r7, 0x0171
	if (c < 32 || c > 126) return;
 8ea:	80 52       	subi	r24, 0x20	; 32
 8ec:	8f 35       	cpi	r24, 0x5F	; 95
 8ee:	08 f0       	brcs	.+2      	; 0x8f2 <display_char+0x40>
 8f0:	9f c0       	rjmp	.+318    	; 0xa30 <display_char+0x17e>
void display_char(char c)
{
	uint16_t x, y;
	PGM_P fdata; 
	uint8_t bits, mask;
	uint16_t sc=display.x, ec=display.x + 4, sp=display.y, ep=display.y + 7;
 8f2:	e3 01       	movw	r28, r6
 8f4:	27 96       	adiw	r28, 0x07	; 7
	if (c < 32 || c > 126) return;
	fdata = (c - ' ')*5 + font5x7;
 8f6:	85 e0       	ldi	r24, 0x05	; 5
 8f8:	98 02       	muls	r25, r24
 8fa:	90 01       	movw	r18, r0
 8fc:	11 24       	eor	r1, r1
 8fe:	24 52       	subi	r18, 0x24	; 36
 900:	30 40       	sbci	r19, 0x00	; 0
	write_cmd(PAGE_ADDRESS_SET);
 902:	14 98       	cbi	0x02, 4	; 2
 904:	8b e2       	ldi	r24, 0x2B	; 43
 906:	88 b9       	out	0x08, r24	; 8
 908:	13 98       	cbi	0x02, 3	; 2
 90a:	13 9a       	sbi	0x02, 3	; 2
 90c:	14 9a       	sbi	0x02, 4	; 2
	write_data16(sp);
 90e:	78 b8       	out	0x08, r7	; 8
 910:	13 98       	cbi	0x02, 3	; 2
 912:	13 9a       	sbi	0x02, 3	; 2
 914:	68 b8       	out	0x08, r6	; 8
 916:	13 98       	cbi	0x02, 3	; 2
 918:	13 9a       	sbi	0x02, 3	; 2
	write_data16(ep);
 91a:	d8 b9       	out	0x08, r29	; 8
 91c:	13 98       	cbi	0x02, 3	; 2
 91e:	13 9a       	sbi	0x02, 3	; 2
 920:	c8 b9       	out	0x08, r28	; 8
 922:	13 98       	cbi	0x02, 3	; 2
 924:	13 9a       	sbi	0x02, 3	; 2
		write_data16(x);
		write_data16(x);
		write_cmd(MEMORY_WRITE);
		bits = pgm_read_byte(fdata++);
		for(y=sp, mask=0x01; y<=ep; y++, mask<<=1)
			write_data16((bits & mask) ? display.foreground : display.background);
 926:	c0 90 72 01 	lds	r12, 0x0172
 92a:	d0 90 73 01 	lds	r13, 0x0173
 92e:	a0 90 74 01 	lds	r10, 0x0174
 932:	b0 90 75 01 	lds	r11, 0x0175
 936:	a8 01       	movw	r20, r16
	fdata = (c - ' ')*5 + font5x7;
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(sp);
	write_data16(ep);
	for(x=sc; x<=ec; x++) {
		write_cmd(COLUMN_ADDRESS_SET);
 938:	9a e2       	ldi	r25, 0x2A	; 42
 93a:	89 2e       	mov	r8, r25
		write_data16(x);
		write_data16(x);
		write_cmd(MEMORY_WRITE);
 93c:	8c e2       	ldi	r24, 0x2C	; 44
 93e:	98 2e       	mov	r9, r24
 940:	36 c0       	rjmp	.+108    	; 0x9ae <display_char+0xfc>
	fdata = (c - ' ')*5 + font5x7;
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(sp);
	write_data16(ep);
	for(x=sc; x<=ec; x++) {
		write_cmd(COLUMN_ADDRESS_SET);
 942:	14 98       	cbi	0x02, 4	; 2
 944:	88 b8       	out	0x08, r8	; 8
 946:	13 98       	cbi	0x02, 3	; 2
 948:	13 9a       	sbi	0x02, 3	; 2
 94a:	14 9a       	sbi	0x02, 4	; 2
		write_data16(x);
 94c:	58 b9       	out	0x08, r21	; 8
 94e:	13 98       	cbi	0x02, 3	; 2
 950:	13 9a       	sbi	0x02, 3	; 2
 952:	48 b9       	out	0x08, r20	; 8
 954:	13 98       	cbi	0x02, 3	; 2
 956:	13 9a       	sbi	0x02, 3	; 2
		write_data16(x);
 958:	58 b9       	out	0x08, r21	; 8
 95a:	13 98       	cbi	0x02, 3	; 2
 95c:	13 9a       	sbi	0x02, 3	; 2
 95e:	48 b9       	out	0x08, r20	; 8
 960:	13 98       	cbi	0x02, 3	; 2
 962:	13 9a       	sbi	0x02, 3	; 2
		write_cmd(MEMORY_WRITE);
 964:	14 98       	cbi	0x02, 4	; 2
 966:	98 b8       	out	0x08, r9	; 8
 968:	13 98       	cbi	0x02, 3	; 2
 96a:	13 9a       	sbi	0x02, 3	; 2
 96c:	14 9a       	sbi	0x02, 4	; 2
		bits = pgm_read_byte(fdata++);
 96e:	f9 01       	movw	r30, r18
 970:	b4 91       	lpm	r27, Z+
 972:	b3 01       	movw	r22, r6
 974:	91 e0       	ldi	r25, 0x01	; 1
 976:	14 c0       	rjmp	.+40     	; 0x9a0 <display_char+0xee>
		for(y=sp, mask=0x01; y<=ep; y++, mask<<=1)
			write_data16((bits & mask) ? display.foreground : display.background);
 978:	a9 2f       	mov	r26, r25
 97a:	ab 23       	and	r26, r27
 97c:	11 f4       	brne	.+4      	; 0x982 <display_char+0xd0>
 97e:	8b 2d       	mov	r24, r11
 980:	01 c0       	rjmp	.+2      	; 0x984 <display_char+0xd2>
 982:	8d 2d       	mov	r24, r13
 984:	88 b9       	out	0x08, r24	; 8
 986:	13 98       	cbi	0x02, 3	; 2
 988:	13 9a       	sbi	0x02, 3	; 2
 98a:	aa 23       	and	r26, r26
 98c:	11 f4       	brne	.+4      	; 0x992 <display_char+0xe0>
 98e:	8a 2d       	mov	r24, r10
 990:	01 c0       	rjmp	.+2      	; 0x994 <display_char+0xe2>
 992:	8c 2d       	mov	r24, r12
 994:	88 b9       	out	0x08, r24	; 8
 996:	13 98       	cbi	0x02, 3	; 2
 998:	13 9a       	sbi	0x02, 3	; 2
		write_cmd(COLUMN_ADDRESS_SET);
		write_data16(x);
		write_data16(x);
		write_cmd(MEMORY_WRITE);
		bits = pgm_read_byte(fdata++);
		for(y=sp, mask=0x01; y<=ep; y++, mask<<=1)
 99a:	6f 5f       	subi	r22, 0xFF	; 255
 99c:	7f 4f       	sbci	r23, 0xFF	; 255
 99e:	99 0f       	add	r25, r25
 9a0:	c6 17       	cp	r28, r22
 9a2:	d7 07       	cpc	r29, r23
 9a4:	48 f7       	brcc	.-46     	; 0x978 <display_char+0xc6>
	for(x=sc; x<=ec; x++) {
		write_cmd(COLUMN_ADDRESS_SET);
		write_data16(x);
		write_data16(x);
		write_cmd(MEMORY_WRITE);
		bits = pgm_read_byte(fdata++);
 9a6:	2f 5f       	subi	r18, 0xFF	; 255
 9a8:	3f 4f       	sbci	r19, 0xFF	; 255
	if (c < 32 || c > 126) return;
	fdata = (c - ' ')*5 + font5x7;
	write_cmd(PAGE_ADDRESS_SET);
	write_data16(sp);
	write_data16(ep);
	for(x=sc; x<=ec; x++) {
 9aa:	4f 5f       	subi	r20, 0xFF	; 255
 9ac:	5f 4f       	sbci	r21, 0xFF	; 255
 9ae:	e4 16       	cp	r14, r20
 9b0:	f5 06       	cpc	r15, r21
 9b2:	38 f6       	brcc	.-114    	; 0x942 <display_char+0x90>
		write_cmd(MEMORY_WRITE);
		bits = pgm_read_byte(fdata++);
		for(y=sp, mask=0x01; y<=ep; y++, mask<<=1)
			write_data16((bits & mask) ? display.foreground : display.background);
	}
	write_cmd(COLUMN_ADDRESS_SET);
 9b4:	14 98       	cbi	0x02, 4	; 2
 9b6:	8a e2       	ldi	r24, 0x2A	; 42
 9b8:	88 b9       	out	0x08, r24	; 8
 9ba:	13 98       	cbi	0x02, 3	; 2
 9bc:	13 9a       	sbi	0x02, 3	; 2
 9be:	14 9a       	sbi	0x02, 4	; 2
	write_data16(x);
 9c0:	58 b9       	out	0x08, r21	; 8
 9c2:	13 98       	cbi	0x02, 3	; 2
 9c4:	13 9a       	sbi	0x02, 3	; 2
 9c6:	48 b9       	out	0x08, r20	; 8
 9c8:	13 98       	cbi	0x02, 3	; 2
 9ca:	13 9a       	sbi	0x02, 3	; 2
	write_data16(x);
 9cc:	58 b9       	out	0x08, r21	; 8
 9ce:	13 98       	cbi	0x02, 3	; 2
 9d0:	13 9a       	sbi	0x02, 3	; 2
 9d2:	48 b9       	out	0x08, r20	; 8
 9d4:	13 98       	cbi	0x02, 3	; 2
 9d6:	13 9a       	sbi	0x02, 3	; 2
	write_cmd(MEMORY_WRITE);
 9d8:	14 98       	cbi	0x02, 4	; 2
 9da:	8c e2       	ldi	r24, 0x2C	; 44
 9dc:	88 b9       	out	0x08, r24	; 8
 9de:	13 98       	cbi	0x02, 3	; 2
 9e0:	13 9a       	sbi	0x02, 3	; 2
 9e2:	14 9a       	sbi	0x02, 4	; 2
 9e4:	c3 01       	movw	r24, r6
 9e6:	07 c0       	rjmp	.+14     	; 0x9f6 <display_char+0x144>
	for(y=sp; y<=ep; y++)
		write_data16(display.background);
 9e8:	b8 b8       	out	0x08, r11	; 8
 9ea:	13 98       	cbi	0x02, 3	; 2
 9ec:	13 9a       	sbi	0x02, 3	; 2
 9ee:	a8 b8       	out	0x08, r10	; 8
 9f0:	13 98       	cbi	0x02, 3	; 2
 9f2:	13 9a       	sbi	0x02, 3	; 2
	}
	write_cmd(COLUMN_ADDRESS_SET);
	write_data16(x);
	write_data16(x);
	write_cmd(MEMORY_WRITE);
	for(y=sp; y<=ep; y++)
 9f4:	01 96       	adiw	r24, 0x01	; 1
 9f6:	c8 17       	cp	r28, r24
 9f8:	d9 07       	cpc	r29, r25
 9fa:	b0 f7       	brcc	.-20     	; 0x9e8 <display_char+0x136>
		write_data16(display.background);

	display.x += 6;
 9fc:	98 01       	movw	r18, r16
 9fe:	2a 5f       	subi	r18, 0xFA	; 250
 a00:	3f 4f       	sbci	r19, 0xFF	; 255
 a02:	30 93 6f 01 	sts	0x016F, r19
 a06:	20 93 6e 01 	sts	0x016E, r18
	if (display.x >= display.width) { display.x=0; display.y+=8; }
 a0a:	80 91 68 01 	lds	r24, 0x0168
 a0e:	90 91 69 01 	lds	r25, 0x0169
 a12:	28 17       	cp	r18, r24
 a14:	39 07       	cpc	r19, r25
 a16:	60 f0       	brcs	.+24     	; 0xa30 <display_char+0x17e>
 a18:	10 92 6f 01 	sts	0x016F, r1
 a1c:	10 92 6e 01 	sts	0x016E, r1
 a20:	88 e0       	ldi	r24, 0x08	; 8
 a22:	90 e0       	ldi	r25, 0x00	; 0
 a24:	68 0e       	add	r6, r24
 a26:	79 1e       	adc	r7, r25
 a28:	70 92 71 01 	sts	0x0171, r7
 a2c:	60 92 70 01 	sts	0x0170, r6
}
 a30:	df 91       	pop	r29
 a32:	cf 91       	pop	r28
 a34:	1f 91       	pop	r17
 a36:	0f 91       	pop	r16
 a38:	ff 90       	pop	r15
 a3a:	ef 90       	pop	r14
 a3c:	df 90       	pop	r13
 a3e:	cf 90       	pop	r12
 a40:	bf 90       	pop	r11
 a42:	af 90       	pop	r10
 a44:	9f 90       	pop	r9
 a46:	8f 90       	pop	r8
 a48:	7f 90       	pop	r7
 a4a:	6f 90       	pop	r6
 a4c:	08 95       	ret

00000a4e <display_string>:

void display_string(char *str)
{
 a4e:	1f 93       	push	r17
 a50:	cf 93       	push	r28
 a52:	df 93       	push	r29
 a54:	ec 01       	movw	r28, r24
 a56:	10 e0       	ldi	r17, 0x00	; 0
 a58:	03 c0       	rjmp	.+6      	; 0xa60 <display_string+0x12>
	uint8_t i;
	for(i=0; str[i]; i++) 
		display_char(str[i]);
 a5a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <display_char>
}

void display_string(char *str)
{
	uint8_t i;
	for(i=0; str[i]; i++) 
 a5e:	1f 5f       	subi	r17, 0xFF	; 255
 a60:	fe 01       	movw	r30, r28
 a62:	e1 0f       	add	r30, r17
 a64:	f1 1d       	adc	r31, r1
 a66:	80 81       	ld	r24, Z
 a68:	88 23       	and	r24, r24
 a6a:	b9 f7       	brne	.-18     	; 0xa5a <display_string+0xc>
		display_char(str[i]);
}
 a6c:	df 91       	pop	r29
 a6e:	cf 91       	pop	r28
 a70:	1f 91       	pop	r17
 a72:	08 95       	ret

00000a74 <main>:
#include "lcd.c"

#include "rfm12.h"

int main ( void )
{
 a74:	af 92       	push	r10
 a76:	bf 92       	push	r11
 a78:	cf 92       	push	r12
 a7a:	df 92       	push	r13
 a7c:	ef 92       	push	r14
 a7e:	ff 92       	push	r15
 a80:	0f 93       	push	r16
 a82:	1f 93       	push	r17
 a84:	df 93       	push	r29
 a86:	cf 93       	push	r28
 a88:	cd b7       	in	r28, 0x3d	; 61
 a8a:	de b7       	in	r29, 0x3e	; 62
 a8c:	27 97       	sbiw	r28, 0x07	; 7
 a8e:	0f b6       	in	r0, 0x3f	; 63
 a90:	f8 94       	cli
 a92:	de bf       	out	0x3e, r29	; 62
 a94:	0f be       	out	0x3f, r0	; 63
 a96:	cd bf       	out	0x3d, r28	; 61
	init_lcd();
 a98:	0e 94 a4 02 	call	0x548	; 0x548 <init_lcd>
	set_orientation(East);
 a9c:	83 e0       	ldi	r24, 0x03	; 3
 a9e:	90 e0       	ldi	r25, 0x00	; 0
 aa0:	0e 94 b1 02 	call	0x562	; 0x562 <set_orientation>
 aa4:	88 ee       	ldi	r24, 0xE8	; 232
 aa6:	93 e0       	ldi	r25, 0x03	; 3
 aa8:	2c e2       	ldi	r18, 0x2C	; 44
 aaa:	31 e0       	ldi	r19, 0x01	; 1
 aac:	f9 01       	movw	r30, r18
 aae:	31 97       	sbiw	r30, 0x01	; 1
 ab0:	f1 f7       	brne	.-4      	; 0xaae <main+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 ab2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 ab4:	d9 f7       	brne	.-10     	; 0xaac <main+0x38>

	uint8_t *bufptr;
	uint8_t i;
	uint8_t tv[] = "foobar";
 ab6:	de 01       	movw	r26, r28
 ab8:	11 96       	adiw	r26, 0x01	; 1
 aba:	e1 e6       	ldi	r30, 0x61	; 97
 abc:	f1 e0       	ldi	r31, 0x01	; 1
 abe:	87 e0       	ldi	r24, 0x07	; 7
 ac0:	01 90       	ld	r0, Z+
 ac2:	0d 92       	st	X+, r0
 ac4:	81 50       	subi	r24, 0x01	; 1
 ac6:	e1 f7       	brne	.-8      	; 0xac0 <main+0x4c>
	#ifdef LED_PORT
		LED_DDR |= _BV(LED_BIT); //enable LED if any
	#endif

	_delay_ms(100);  //little delay for the rfm12 to initialize properly
	rfm12_init();    //init the RFM12
 ac8:	0e 94 30 07 	call	0xe60	; 0xe60 <rfm12_init>
	
	sei();           //interrupts on
 acc:	78 94       	sei

	display_string("\r\n" "RFM12 Pingpong test\r\n");
 ace:	83 e3       	ldi	r24, 0x33	; 51
 ad0:	91 e0       	ldi	r25, 0x01	; 1
 ad2:	0e 94 27 05 	call	0xa4e	; 0xa4e <display_string>
 ad6:	ee 24       	eor	r14, r14
 ad8:	ff 24       	eor	r15, r15

		ticker ++;
		if(ticker == 3000){
			ticker = 0;
			display_string(".\r\n");
			rfm12_tx (sizeof(tv), 0, tv);
 ada:	5e 01       	movw	r10, r28
 adc:	08 94       	sec
 ade:	a1 1c       	adc	r10, r1
 ae0:	b1 1c       	adc	r11, r1
 ae2:	bc e2       	ldi	r27, 0x2C	; 44
 ae4:	cb 2e       	mov	r12, r27
 ae6:	b1 e0       	ldi	r27, 0x01	; 1
 ae8:	db 2e       	mov	r13, r27
	//! Inline function to return the rx buffer status byte.
	/** \returns STATUS_FREE or STATUS_COMPLETE
	* \see \ref rxtx_states "rx buffer states", rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer(), rfm12_rx_clear() and rf_rx_buffer_t
	*/
	static inline uint8_t rfm12_rx_status(void) {
		return rf_rx_buffers[ctrl.buffer_out_num].status;
 aea:	80 91 7e 01 	lds	r24, 0x017E
 aee:	90 e0       	ldi	r25, 0x00	; 0
 af0:	fc 01       	movw	r30, r24
 af2:	a5 e0       	ldi	r26, 0x05	; 5
 af4:	ee 0f       	add	r30, r30
 af6:	ff 1f       	adc	r31, r31
 af8:	aa 95       	dec	r26
 afa:	e1 f7       	brne	.-8      	; 0xaf4 <main+0x80>
 afc:	88 0f       	add	r24, r24
 afe:	99 1f       	adc	r25, r25
 b00:	e8 0f       	add	r30, r24
 b02:	f9 1f       	adc	r31, r25
 b04:	e1 58       	subi	r30, 0x81	; 129
 b06:	fe 4f       	sbci	r31, 0xFE	; 254
 b08:	80 81       	ld	r24, Z

	display_string("\r\n" "RFM12 Pingpong test\r\n");

	while (42) //while the universe and everything
	{
		if (rfm12_rx_status() == STATUS_COMPLETE)
 b0a:	82 30       	cpi	r24, 0x02	; 2
 b0c:	a9 f5       	brne	.+106    	; 0xb78 <main+0x104>
			//blink the LED
			#ifdef LED_PORT
				LED_PORT ^= _BV(LED_BIT);
			#endif

			display_string("new packet: \"");
 b0e:	8b e4       	ldi	r24, 0x4B	; 75
 b10:	91 e0       	ldi	r25, 0x01	; 1
 b12:	0e 94 27 05 	call	0xa4e	; 0xa4e <display_string>
	//! Inline function to retreive current rf buffer contents.
	/** \returns A pointer to the current receive buffer contents
	* \see rfm12_rx_status(), rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_clear() and rf_rx_buffer_t
	*/
	static inline uint8_t *rfm12_rx_buffer(void) {
		return (uint8_t*) rf_rx_buffers[ctrl.buffer_out_num].buffer;
 b16:	00 91 7e 01 	lds	r16, 0x017E
 b1a:	10 e0       	ldi	r17, 0x00	; 0
 b1c:	15 c0       	rjmp	.+42     	; 0xb48 <main+0xd4>
			bufptr = rfm12_rx_buffer(); //get the address of the current rx buffer

			// dump buffer contents to uart			
			for (i=0;i<rfm12_rx_len();i++)
			{
				display_string( bufptr[i] );
 b1e:	80 2f       	mov	r24, r16
 b20:	90 e0       	ldi	r25, 0x00	; 0
 b22:	fc 01       	movw	r30, r24
 b24:	65 e0       	ldi	r22, 0x05	; 5
 b26:	ee 0f       	add	r30, r30
 b28:	ff 1f       	adc	r31, r31
 b2a:	6a 95       	dec	r22
 b2c:	e1 f7       	brne	.-8      	; 0xb26 <main+0xb2>
 b2e:	88 0f       	add	r24, r24
 b30:	99 1f       	adc	r25, r25
 b32:	e8 0f       	add	r30, r24
 b34:	f9 1f       	adc	r31, r25
 b36:	e1 58       	subi	r30, 0x81	; 129
 b38:	fe 4f       	sbci	r31, 0xFE	; 254
 b3a:	e1 0f       	add	r30, r17
 b3c:	f1 1d       	adc	r31, r1
 b3e:	84 81       	ldd	r24, Z+4	; 0x04
 b40:	90 e0       	ldi	r25, 0x00	; 0
 b42:	0e 94 27 05 	call	0xa4e	; 0xa4e <display_string>
			display_string("new packet: \"");

			bufptr = rfm12_rx_buffer(); //get the address of the current rx buffer

			// dump buffer contents to uart			
			for (i=0;i<rfm12_rx_len();i++)
 b46:	1f 5f       	subi	r17, 0xFF	; 255
 b48:	80 91 7e 01 	lds	r24, 0x017E
 b4c:	90 e0       	ldi	r25, 0x00	; 0
 b4e:	fc 01       	movw	r30, r24
 b50:	45 e0       	ldi	r20, 0x05	; 5
 b52:	ee 0f       	add	r30, r30
 b54:	ff 1f       	adc	r31, r31
 b56:	4a 95       	dec	r20
 b58:	e1 f7       	brne	.-8      	; 0xb52 <main+0xde>
 b5a:	88 0f       	add	r24, r24
 b5c:	99 1f       	adc	r25, r25
 b5e:	e8 0f       	add	r30, r24
 b60:	f9 1f       	adc	r31, r25
 b62:	e1 58       	subi	r30, 0x81	; 129
 b64:	fe 4f       	sbci	r31, 0xFE	; 254
 b66:	81 81       	ldd	r24, Z+1	; 0x01
 b68:	18 17       	cp	r17, r24
 b6a:	c8 f2       	brcs	.-78     	; 0xb1e <main+0xaa>
			{
				display_string( bufptr[i] );
			}
			
			display_string("\"\r\n");
 b6c:	89 e5       	ldi	r24, 0x59	; 89
 b6e:	91 e0       	ldi	r25, 0x01	; 1
 b70:	0e 94 27 05 	call	0xa4e	; 0xa4e <display_string>
			
			// tell the implementation that the buffer
			// can be reused for the next data.
			rfm12_rx_clear();
 b74:	0e 94 1a 07 	call	0xe34	; 0xe34 <rfm12_rx_clear>
		}


		ticker ++;
 b78:	08 94       	sec
 b7a:	e1 1c       	adc	r14, r1
 b7c:	f1 1c       	adc	r15, r1
		if(ticker == 3000){
 b7e:	88 eb       	ldi	r24, 0xB8	; 184
 b80:	e8 16       	cp	r14, r24
 b82:	8b e0       	ldi	r24, 0x0B	; 11
 b84:	f8 06       	cpc	r15, r24
 b86:	59 f4       	brne	.+22     	; 0xb9e <main+0x12a>
			ticker = 0;
			display_string(".\r\n");
 b88:	8d e5       	ldi	r24, 0x5D	; 93
 b8a:	91 e0       	ldi	r25, 0x01	; 1
 b8c:	0e 94 27 05 	call	0xa4e	; 0xa4e <display_string>
			rfm12_tx (sizeof(tv), 0, tv);
 b90:	87 e0       	ldi	r24, 0x07	; 7
 b92:	60 e0       	ldi	r22, 0x00	; 0
 b94:	a5 01       	movw	r20, r10
 b96:	0e 94 66 07 	call	0xecc	; 0xecc <rfm12_tx>
 b9a:	ee 24       	eor	r14, r14
 b9c:	ff 24       	eor	r15, r15
		}

		//rfm12 needs to be called from your main loop periodically.
		//it checks if the rf channel is free (no one else transmitting), and then
		//sends packets, that have been queued by rfm12_tx above.
		rfm12_tick();
 b9e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <rfm12_tick>
 ba2:	c6 01       	movw	r24, r12
 ba4:	01 97       	sbiw	r24, 0x01	; 1
 ba6:	f1 f7       	brne	.-4      	; 0xba4 <main+0x130>
 ba8:	a0 cf       	rjmp	.-192    	; 0xaea <main+0x76>

00000baa <rfm12_data>:


//non-inlined version of rfm12_data
//warning: without the attribute, gcc will inline this even if -Os is set
static void __attribute__ ((noinline)) rfm12_data(uint16_t d) {
	SS_ASSERT();
 baa:	2a 98       	cbi	0x05, 2	; 5
	#if !(RFM12_SPI_SOFTWARE)
		SPDR = d >> 8;
 bac:	9e bd       	out	0x2e, r25	; 46
		while (!(SPSR & (1<<SPIF)));
 bae:	0d b4       	in	r0, 0x2d	; 45
 bb0:	07 fe       	sbrs	r0, 7
 bb2:	fd cf       	rjmp	.-6      	; 0xbae <rfm12_data+0x4>

		SPDR = d & 0xff;
 bb4:	8e bd       	out	0x2e, r24	; 46
		while (!(SPSR & (1<<SPIF)));
 bb6:	0d b4       	in	r0, 0x2d	; 45
 bb8:	07 fe       	sbrs	r0, 7
 bba:	fd cf       	rjmp	.-6      	; 0xbb6 <rfm12_data+0xc>
	#else
		spi_data(d >> 8);
		spi_data(d & 0xff);
	#endif
	SS_RELEASE();
 bbc:	2a 9a       	sbi	0x05, 2	; 5
}
 bbe:	08 95       	ret

00000bc0 <rfm12_read>:

//non-inlined version of rfm12_read
//warning: without the attribute, gcc will inline this even if -Os is set
static uint16_t __attribute__ ((noinline)) rfm12_read(uint16_t c) {
	uint16_t retval;
	SS_ASSERT();
 bc0:	2a 98       	cbi	0x05, 2	; 5

	#if !(RFM12_SPI_SOFTWARE)
		SPDR = c >> 8;
 bc2:	9e bd       	out	0x2e, r25	; 46
		while (!(SPSR & (1<<SPIF)));
 bc4:	0d b4       	in	r0, 0x2d	; 45
 bc6:	07 fe       	sbrs	r0, 7
 bc8:	fd cf       	rjmp	.-6      	; 0xbc4 <rfm12_read+0x4>
		retval = SPDR << 8;
 bca:	3e b5       	in	r19, 0x2e	; 46
		SPDR = c & 0xff;
 bcc:	8e bd       	out	0x2e, r24	; 46
		while (!(SPSR & (1<<SPIF)));
 bce:	0d b4       	in	r0, 0x2d	; 45
 bd0:	07 fe       	sbrs	r0, 7
 bd2:	fd cf       	rjmp	.-6      	; 0xbce <rfm12_read+0xe>
		retval |= SPDR;
 bd4:	2e b5       	in	r18, 0x2e	; 46
	SS_ASSERT();

	#if !(RFM12_SPI_SOFTWARE)
		SPDR = c >> 8;
		while (!(SPSR & (1<<SPIF)));
		retval = SPDR << 8;
 bd6:	93 2f       	mov	r25, r19
 bd8:	80 e0       	ldi	r24, 0x00	; 0
	#else
		retval = spi_data(c >> 8);
		retval <<= 8;
		retval |= spi_data(c & 0xff);
	#endif
	SS_RELEASE();
 bda:	2a 9a       	sbi	0x05, 2	; 5
 bdc:	30 e0       	ldi	r19, 0x00	; 0
 bde:	28 2b       	or	r18, r24
 be0:	39 2b       	or	r19, r25
	return retval;
}
 be2:	c9 01       	movw	r24, r18
 be4:	08 95       	ret

00000be6 <__vector_2>:
#if (RFM12_USE_POLLING)
void rfm12_poll(void)
#else
ISR(RFM12_INT_VECT, ISR_NOBLOCK)
#endif
{
 be6:	78 94       	sei
 be8:	1f 92       	push	r1
 bea:	0f 92       	push	r0
 bec:	0f b6       	in	r0, 0x3f	; 63
 bee:	0f 92       	push	r0
 bf0:	11 24       	eor	r1, r1
 bf2:	df 92       	push	r13
 bf4:	ef 92       	push	r14
 bf6:	ff 92       	push	r15
 bf8:	0f 93       	push	r16
 bfa:	1f 93       	push	r17
 bfc:	2f 93       	push	r18
 bfe:	3f 93       	push	r19
 c00:	4f 93       	push	r20
 c02:	5f 93       	push	r21
 c04:	6f 93       	push	r22
 c06:	7f 93       	push	r23
 c08:	8f 93       	push	r24
 c0a:	9f 93       	push	r25
 c0c:	af 93       	push	r26
 c0e:	bf 93       	push	r27
 c10:	ef 93       	push	r30
 c12:	ff 93       	push	r31
	RFM12_INT_OFF();
 c14:	e9 98       	cbi	0x1d, 1	; 29
 c16:	00 91 78 01 	lds	r16, 0x0178
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	do {
		//clear AVR int flag
#ifdef __PLATFORM_AVR__
		RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 c1a:	12 e0       	ldi	r17, 0x02	; 2
 c1c:	e1 2e       	mov	r14, r17
							checksum ^= data;

							//put next byte into buffer, if there is enough space
							if (ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3)) {
								//hackhack: begin writing to struct at offsetof len
								(& rf_rx_buffers[ctrl.buffer_in_num].len)[ctrl.bytecount] = data;
 c1e:	b2 e2       	ldi	r27, 0x22	; 34
 c20:	db 2e       	mov	r13, r27
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;

						//init the bytecounter - remember, we will read the length byte, so this must be 1
						ctrl.bytecount = 1;
 c22:	ff 24       	eor	r15, r15
 c24:	f3 94       	inc	r15
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	do {
		//clear AVR int flag
#ifdef __PLATFORM_AVR__
		RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 c26:	ec ba       	out	0x1c, r14	; 28
/* @description reads the upper 8 bits of the status
 * register (the interrupt flags)
 */
static uint8_t rfm12_read_int_flags_inline(void) {
	#if !(RFM12_SPI_SOFTWARE)
		SS_ASSERT();
 c28:	2a 98       	cbi	0x05, 2	; 5
		SPDR = 0;
 c2a:	1e bc       	out	0x2e, r1	; 46
		while (!(SPSR & (1<<SPIF)));
 c2c:	0d b4       	in	r0, 0x2d	; 45
 c2e:	07 fe       	sbrs	r0, 7
 c30:	fd cf       	rjmp	.-6      	; 0xc2c <__vector_2+0x46>
		SS_RELEASE();
 c32:	2a 9a       	sbi	0x05, 2	; 5
				rfm12_data(ctrl.pwrmgt_shadow);
			}
		#endif /* RFM12_USE_WAKEUP_TIMER */

		//check if the fifo interrupt occurred
		if (status & (RFM12_STATUS_FFIT>>8)) {
 c34:	0e b4       	in	r0, 0x2e	; 46
 c36:	07 fe       	sbrs	r0, 7
 c38:	99 c0       	rjmp	.+306    	; 0xd6c <__vector_2+0x186>
			//yes
			recheck_interrupt = 1;
			//see what we have to do (start rx, rx or tx)
			switch (ctrl.rfm12_state) {
 c3a:	10 91 79 01 	lds	r17, 0x0179
 c3e:	11 30       	cpi	r17, 0x01	; 1
 c40:	b9 f1       	breq	.+110    	; 0xcb0 <__vector_2+0xca>
 c42:	11 30       	cpi	r17, 0x01	; 1
 c44:	20 f0       	brcs	.+8      	; 0xc4e <__vector_2+0x68>
 c46:	12 30       	cpi	r17, 0x02	; 2
 c48:	09 f0       	breq	.+2      	; 0xc4c <__vector_2+0x66>
 c4a:	85 c0       	rjmp	.+266    	; 0xd56 <__vector_2+0x170>
 c4c:	69 c0       	rjmp	.+210    	; 0xd20 <__vector_2+0x13a>
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;

						//init the bytecounter - remember, we will read the length byte, so this must be 1
						ctrl.bytecount = 1;
 c4e:	f0 92 7c 01 	sts	0x017C, r15

						//read the length byte,  and write it to the checksum
						//remember, the first byte is the length byte
						data = rfm12_read(RFM12_CMD_READ);
 c52:	80 e0       	ldi	r24, 0x00	; 0
 c54:	90 eb       	ldi	r25, 0xB0	; 176
 c56:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <rfm12_read>
 c5a:	08 2f       	mov	r16, r24
						checksum = data;

						//add the packet overhead and store it into a working variable
						ctrl.num_bytes = data + PACKET_OVERHEAD;
 c5c:	0d 5f       	subi	r16, 0xFD	; 253
 c5e:	00 93 7b 01 	sts	0x017B, r16
 c62:	03 50       	subi	r16, 0x03	; 3
							uart_putc(data);
						#endif

						//see whether our buffer is free
						//FIXME: put this into global statekeeping struct, the free state can be set by the function which pulls the packet, i guess
						if (rf_rx_buffers[ctrl.buffer_in_num].status == STATUS_FREE) {
 c64:	20 91 7d 01 	lds	r18, 0x017D
 c68:	82 2f       	mov	r24, r18
 c6a:	90 e0       	ldi	r25, 0x00	; 0
 c6c:	fc 01       	movw	r30, r24
 c6e:	a5 e0       	ldi	r26, 0x05	; 5
 c70:	ee 0f       	add	r30, r30
 c72:	ff 1f       	adc	r31, r31
 c74:	aa 95       	dec	r26
 c76:	e1 f7       	brne	.-8      	; 0xc70 <__vector_2+0x8a>
 c78:	88 0f       	add	r24, r24
 c7a:	99 1f       	adc	r25, r25
 c7c:	e8 0f       	add	r30, r24
 c7e:	f9 1f       	adc	r31, r25
 c80:	e1 58       	subi	r30, 0x81	; 129
 c82:	fe 4f       	sbci	r31, 0xFE	; 254
 c84:	80 81       	ld	r24, Z
 c86:	88 23       	and	r24, r24
 c88:	09 f0       	breq	.+2      	; 0xc8c <__vector_2+0xa6>
 c8a:	65 c0       	rjmp	.+202    	; 0xd56 <__vector_2+0x170>
							//the current receive buffer is empty, so we start receiving
							ctrl.rfm12_state = STATE_RX_ACTIVE;
 c8c:	f0 92 79 01 	sts	0x0179, r15

							//store the received length into the packet buffer
							//this length field will be used by application reading the
							//buffer.
							rf_rx_buffers[ctrl.buffer_in_num].len = data;
 c90:	82 2f       	mov	r24, r18
 c92:	90 e0       	ldi	r25, 0x00	; 0
 c94:	fc 01       	movw	r30, r24
 c96:	65 e0       	ldi	r22, 0x05	; 5
 c98:	ee 0f       	add	r30, r30
 c9a:	ff 1f       	adc	r31, r31
 c9c:	6a 95       	dec	r22
 c9e:	e1 f7       	brne	.-8      	; 0xc98 <__vector_2+0xb2>
 ca0:	88 0f       	add	r24, r24
 ca2:	99 1f       	adc	r25, r25
 ca4:	e8 0f       	add	r30, r24
 ca6:	f9 1f       	adc	r31, r25
 ca8:	e1 58       	subi	r30, 0x81	; 129
 caa:	fe 4f       	sbci	r31, 0xFE	; 254
 cac:	01 83       	std	Z+1, r16	; 0x01
 cae:	bb cf       	rjmp	.-138    	; 0xc26 <__vector_2+0x40>
				case STATE_RX_ACTIVE: {
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;
						//read a byte
						data = rfm12_read(RFM12_CMD_READ);
 cb0:	80 e0       	ldi	r24, 0x00	; 0
 cb2:	90 eb       	ldi	r25, 0xB0	; 176
 cb4:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <rfm12_read>
 cb8:	28 2f       	mov	r18, r24

						//check if transmission is complete
						if (ctrl.bytecount < ctrl.num_bytes) {
 cba:	90 91 7c 01 	lds	r25, 0x017C
 cbe:	80 91 7b 01 	lds	r24, 0x017B
 cc2:	98 17       	cp	r25, r24
 cc4:	c0 f4       	brcc	.+48     	; 0xcf6 <__vector_2+0x110>
								uart_putc(data);
							#endif

							//xor the remaining bytes onto the checksum
							//note: only the header will be effectively checked
							checksum ^= data;
 cc6:	02 27       	eor	r16, r18

							//put next byte into buffer, if there is enough space
							if (ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3)) {
 cc8:	91 32       	cpi	r25, 0x21	; 33
 cca:	58 f4       	brcc	.+22     	; 0xce2 <__vector_2+0xfc>
								//hackhack: begin writing to struct at offsetof len
								(& rf_rx_buffers[ctrl.buffer_in_num].len)[ctrl.bytecount] = data;
 ccc:	e0 91 7d 01 	lds	r30, 0x017D
 cd0:	ed 9d       	mul	r30, r13
 cd2:	f0 01       	movw	r30, r0
 cd4:	11 24       	eor	r1, r1
 cd6:	31 96       	adiw	r30, 0x01	; 1
 cd8:	e9 0f       	add	r30, r25
 cda:	f1 1d       	adc	r31, r1
 cdc:	e1 58       	subi	r30, 0x81	; 129
 cde:	fe 4f       	sbci	r31, 0xFE	; 254
 ce0:	20 83       	st	Z, r18
							}
#ifndef DISABLE_CHECKSUMM
							//check header against checksum
							if (ctrl.bytecount == 2 && checksum != 0xff) {
 ce2:	80 91 7c 01 	lds	r24, 0x017C
 ce6:	82 30       	cpi	r24, 0x02	; 2
 ce8:	11 f4       	brne	.+4      	; 0xcee <__vector_2+0x108>
 cea:	0f 3f       	cpi	r16, 0xFF	; 255
 cec:	a1 f5       	brne	.+104    	; 0xd56 <__vector_2+0x170>
								break;
							}
#endif

							//increment bytecount
							ctrl.bytecount++;
 cee:	8f 5f       	subi	r24, 0xFF	; 255
 cf0:	80 93 7c 01 	sts	0x017C, r24
 cf4:	98 cf       	rjmp	.-208    	; 0xc26 <__vector_2+0x40>
						#if RFM12_UART_DEBUG >= 2
							uart_putc('D');
						#endif

						//indicate that the buffer is ready to be used
						rf_rx_buffers[ctrl.buffer_in_num].status = STATUS_COMPLETE;
 cf6:	80 91 7d 01 	lds	r24, 0x017D
 cfa:	28 2f       	mov	r18, r24
 cfc:	30 e0       	ldi	r19, 0x00	; 0
 cfe:	f9 01       	movw	r30, r18
 d00:	45 e0       	ldi	r20, 0x05	; 5
 d02:	ee 0f       	add	r30, r30
 d04:	ff 1f       	adc	r31, r31
 d06:	4a 95       	dec	r20
 d08:	e1 f7       	brne	.-8      	; 0xd02 <__vector_2+0x11c>
 d0a:	22 0f       	add	r18, r18
 d0c:	33 1f       	adc	r19, r19
 d0e:	e2 0f       	add	r30, r18
 d10:	f3 1f       	adc	r31, r19
 d12:	e1 58       	subi	r30, 0x81	; 129
 d14:	fe 4f       	sbci	r31, 0xFE	; 254
 d16:	e0 82       	st	Z, r14
								rfm12_rx_callback_func (ctrl.rf_buffer_in->len, ctrl.rf_buffer_in.buffer);
							}
						#endif

						//switch to other buffer
						ctrl.buffer_in_num ^= 1;
 d18:	81 27       	eor	r24, r17
 d1a:	80 93 7d 01 	sts	0x017D, r24
 d1e:	1b c0       	rjmp	.+54     	; 0xd56 <__vector_2+0x170>
					//debug
					#if RFM12_UART_DEBUG >= 2
						uart_putc('T');
					#endif

					if (ctrl.bytecount < ctrl.num_bytes) {
 d20:	20 91 7c 01 	lds	r18, 0x017C
 d24:	80 91 7b 01 	lds	r24, 0x017B
 d28:	28 17       	cp	r18, r24
 d2a:	58 f4       	brcc	.+22     	; 0xd42 <__vector_2+0x15c>
						//load the next byte from our buffer struct.
						rfm12_data( RFM12_CMD_TX | rf_tx_buffer.sync[ctrl.bytecount++]);
 d2c:	e2 2f       	mov	r30, r18
 d2e:	f0 e0       	ldi	r31, 0x00	; 0
 d30:	ed 53       	subi	r30, 0x3D	; 61
 d32:	fe 4f       	sbci	r31, 0xFE	; 254
 d34:	80 81       	ld	r24, Z
 d36:	90 e0       	ldi	r25, 0x00	; 0
 d38:	2f 5f       	subi	r18, 0xFF	; 255
 d3a:	20 93 7c 01 	sts	0x017C, r18
 d3e:	98 6b       	ori	r25, 0xB8	; 184
 d40:	12 c0       	rjmp	.+36     	; 0xd66 <__vector_2+0x180>
					#ifdef TX_LEAVE_HOOK
						TX_LEAVE_HOOK;
					#endif

					//flag the buffer as free again
					ctrl.txstate = STATUS_FREE;
 d42:	10 92 7a 01 	sts	0x017A, r1
					#if RFM12_PWRMGT_SHADOW
						ctrl.pwrmgt_shadow &= ~(RFM12_PWRMGT_ET); /* disable transmitter */
						ctrl.pwrmgt_shadow |= (PWRMGT_RECEIVE);   /* activate predefined receive mode */
						rfm12_data(ctrl.pwrmgt_shadow);
					#else /* no RFM12_PWRMGT_SHADOW */
						rfm12_data( PWRMGT_RECEIVE );
 d46:	81 e8       	ldi	r24, 0x81	; 129
 d48:	92 e8       	ldi	r25, 0x82	; 130
 d4a:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
					#ifdef RX_ENTER_HOOK
						RX_ENTER_HOOK;
					#endif

					//load a dummy byte to clear int status
					rfm12_data( RFM12_CMD_TX | 0xaa);
 d4e:	8a ea       	ldi	r24, 0xAA	; 170
 d50:	98 eb       	ldi	r25, 0xB8	; 184
 d52:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
							break;
					#endif
			}//end of switch

			//set the state machine to idle
			ctrl.rfm12_state = STATE_RX_IDLE;
 d56:	10 92 79 01 	sts	0x0179, r1
			//reset the receiver fifo, if receive mode is not disabled (default)
			#if !(RFM12_TRANSMIT_ONLY)
				#if RFM12_UART_DEBUG >= 2
					uart_putc('F');
				#endif
				rfm12_data( RFM12_CMD_FIFORESET | CLEAR_FIFO_INLINE);
 d5a:	81 e8       	ldi	r24, 0x81	; 129
 d5c:	9a ec       	ldi	r25, 0xCA	; 202
 d5e:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
				rfm12_data( RFM12_CMD_FIFORESET | ACCEPT_DATA_INLINE);
 d62:	83 e8       	ldi	r24, 0x83	; 131
 d64:	9a ec       	ldi	r25, 0xCA	; 202
 d66:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
 d6a:	5d cf       	rjmp	.-326    	; 0xc26 <__vector_2+0x40>
 d6c:	00 93 78 01 	sts	0x0178, r16
	#if RFM12_UART_DEBUG >= 2
		uart_putc('E');
	#endif

	//turn the int back on
	RFM12_INT_ON();
 d70:	e9 9a       	sbi	0x1d, 1	; 29
}
 d72:	ff 91       	pop	r31
 d74:	ef 91       	pop	r30
 d76:	bf 91       	pop	r27
 d78:	af 91       	pop	r26
 d7a:	9f 91       	pop	r25
 d7c:	8f 91       	pop	r24
 d7e:	7f 91       	pop	r23
 d80:	6f 91       	pop	r22
 d82:	5f 91       	pop	r21
 d84:	4f 91       	pop	r20
 d86:	3f 91       	pop	r19
 d88:	2f 91       	pop	r18
 d8a:	1f 91       	pop	r17
 d8c:	0f 91       	pop	r16
 d8e:	ff 90       	pop	r15
 d90:	ef 90       	pop	r14
 d92:	df 90       	pop	r13
 d94:	0f 90       	pop	r0
 d96:	0f be       	out	0x3f, r0	; 63
 d98:	0f 90       	pop	r0
 d9a:	1f 90       	pop	r1
 d9c:	18 95       	reti

00000d9e <rfm12_tick>:
			oldstate = state;
		}
	#endif

	//don't disturb RFM12 if transmitting or receiving
	if (ctrl.rfm12_state != STATE_RX_IDLE) {
 d9e:	80 91 79 01 	lds	r24, 0x0179
 da2:	88 23       	and	r24, r24
 da4:	91 f5       	brne	.+100    	; 0xe0a <rfm12_tick+0x6c>
	//collision detection is enabled by default
	#if !(RFM12_NOCOLLISIONDETECTION)
		//disable the interrupt (as we're working directly with the transceiver now)
		//hint: we could be losing an interrupt here, because we read the status register.
		//this applys for the Wakeup timer, as it's flag is reset by reading.
		RFM12_INT_OFF();
 da6:	e9 98       	cbi	0x1d, 1	; 29
		status = rfm12_read(RFM12_CMD_STATUS);
 da8:	80 e0       	ldi	r24, 0x00	; 0
 daa:	90 e0       	ldi	r25, 0x00	; 0
 dac:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <rfm12_read>
		RFM12_INT_ON();
 db0:	e9 9a       	sbi	0x1d, 1	; 29
				RFM12_INT_ON();
			}
		#endif /* RFM12_USE_WAKEUP_TIMER */

		//check if we see a carrier
		if (status & RFM12_STATUS_RSSI) {
 db2:	90 ff       	sbrs	r25, 0
 db4:	02 c0       	rjmp	.+4      	; 0xdba <rfm12_tick+0x1c>
			//yes: reset free counter and return
			channel_free_count = CHANNEL_FREE_TIME;
 db6:	88 ec       	ldi	r24, 0xC8	; 200
 db8:	05 c0       	rjmp	.+10     	; 0xdc4 <rfm12_tick+0x26>
			return;
		}
		//no

		//is the channel free long enough ?
		if (channel_free_count != 0) {
 dba:	80 91 76 01 	lds	r24, 0x0176
 dbe:	88 23       	and	r24, r24
 dc0:	21 f0       	breq	.+8      	; 0xdca <rfm12_tick+0x2c>
			//no:
			channel_free_count--; // decrement counter
 dc2:	81 50       	subi	r24, 0x01	; 1
 dc4:	80 93 76 01 	sts	0x0176, r24
 dc8:	08 95       	ret
		}
		//yes: we can begin transmitting
	#endif

	//do we have something to transmit?
	if (ctrl.txstate == STATUS_OCCUPIED) { //yes: start transmitting
 dca:	80 91 7a 01 	lds	r24, 0x017A
 dce:	81 30       	cpi	r24, 0x01	; 1
 dd0:	e1 f4       	brne	.+56     	; 0xe0a <rfm12_tick+0x6c>
		//we won't loose interrupts, as the AVR caches them in the int flag.
		//we could disturb an ongoing reception,
		//if it has just started some cpu cycles ago
		//(as the check for this case is some lines (cpu cycles) above)
		//anyhow, we MUST transmit at some point...
		RFM12_INT_OFF();
 dd2:	e9 98       	cbi	0x1d, 1	; 29

		#if RFM12_PWRMGT_SHADOW
			ctrl.pwrmgt_shadow &= ~(RFM12_PWRMGT_ER); /* disable receiver */
			rfm12_data(ctrl.pwrmgt_shadow);
		#else
			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT ); /* disable receiver */
 dd4:	81 e0       	ldi	r24, 0x01	; 1
 dd6:	92 e8       	ldi	r25, 0x82	; 130
 dd8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
			RX_LEAVE_HOOK;
		#endif

		//calculate number of bytes to be sent by ISR
		//2 sync bytes + len byte + type byte + checksum + message length + 1 dummy byte
		ctrl.num_bytes = rf_tx_buffer.len + 6;
 ddc:	80 91 c5 01 	lds	r24, 0x01C5
 de0:	8a 5f       	subi	r24, 0xFA	; 250
 de2:	80 93 7b 01 	sts	0x017B, r24

		//reset byte sent counter
		ctrl.bytecount = 0;
 de6:	10 92 7c 01 	sts	0x017C, r1

		//set mode for interrupt handler
		ctrl.rfm12_state = STATE_TX;
 dea:	82 e0       	ldi	r24, 0x02	; 2
 dec:	80 93 79 01 	sts	0x0179, r24
		#endif

		//fill 2byte 0xAA preamble into data register
		//the preamble helps the receivers AFC circuit to lock onto the exact frequency
		//(hint: the tx FIFO [if el is enabled] is two staged, so we can safely write 2 bytes before starting)
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 df0:	8a ea       	ldi	r24, 0xAA	; 170
 df2:	98 eb       	ldi	r25, 0xB8	; 184
 df4:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 df8:	8a ea       	ldi	r24, 0xAA	; 170
 dfa:	98 eb       	ldi	r25, 0xB8	; 184
 dfc:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
		//set ET in power register to enable transmission (hint: TX starts now)
		#if RFM12_PWRMGT_SHADOW
			ctrl.pwrmgt_shadow |= RFM12_PWRMGT_ET;
			rfm12_data (ctrl.pwrmgt_shadow);
		#else
			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT | RFM12_PWRMGT_ET);
 e00:	81 e2       	ldi	r24, 0x21	; 33
 e02:	92 e8       	ldi	r25, 0x82	; 130
 e04:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
		#endif

		//enable the interrupt to continue the transmission
		RFM12_INT_ON();
 e08:	e9 9a       	sbi	0x1d, 1	; 29
 e0a:	08 95       	ret

00000e0c <rfm12_start_tx>:
#if (RFM12_NORETURNS)
void
#else
uint8_t
#endif
rfm12_start_tx(uint8_t type, uint8_t length) {
 e0c:	98 2f       	mov	r25, r24
	//exit if the buffer isn't free
	if (ctrl.txstate != STATUS_FREE)
 e0e:	80 91 7a 01 	lds	r24, 0x017A
 e12:	88 23       	and	r24, r24
 e14:	11 f0       	breq	.+4      	; 0xe1a <rfm12_start_tx+0xe>
 e16:	83 e0       	ldi	r24, 0x03	; 3
 e18:	08 95       	ret
		return TXRETURN(RFM12_TX_OCCUPIED);

	//write airlab header to buffer
	rf_tx_buffer.len = length;
 e1a:	60 93 c5 01 	sts	0x01C5, r22
	rf_tx_buffer.type = type;
 e1e:	90 93 c6 01 	sts	0x01C6, r25
	rf_tx_buffer.checksum = length ^ type ^ 0xff;
 e22:	69 27       	eor	r22, r25
 e24:	60 95       	com	r22
 e26:	60 93 c7 01 	sts	0x01C7, r22

	//schedule packet for transmission
	ctrl.txstate = STATUS_OCCUPIED;
 e2a:	81 e0       	ldi	r24, 0x01	; 1
 e2c:	80 93 7a 01 	sts	0x017A, r24
 e30:	80 e8       	ldi	r24, 0x80	; 128

	return TXRETURN(RFM12_TX_ENQUEUED);
}
 e32:	08 95       	ret

00000e34 <rfm12_rx_clear>:
	* \see rfm12_rx_status(), rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer() and rf_rx_buffers
	*/
	//warning: without the attribute, gcc will inline this even if -Os is set
	void __attribute__((noinline)) rfm12_rx_clear(void) {
			//mark the current buffer as empty
			rf_rx_buffers[ctrl.buffer_out_num].status = STATUS_FREE;
 e34:	20 91 7e 01 	lds	r18, 0x017E
 e38:	82 2f       	mov	r24, r18
 e3a:	90 e0       	ldi	r25, 0x00	; 0
 e3c:	fc 01       	movw	r30, r24
 e3e:	45 e0       	ldi	r20, 0x05	; 5
 e40:	ee 0f       	add	r30, r30
 e42:	ff 1f       	adc	r31, r31
 e44:	4a 95       	dec	r20
 e46:	e1 f7       	brne	.-8      	; 0xe40 <rfm12_rx_clear+0xc>
 e48:	88 0f       	add	r24, r24
 e4a:	99 1f       	adc	r25, r25
 e4c:	e8 0f       	add	r30, r24
 e4e:	f9 1f       	adc	r31, r25
 e50:	e1 58       	subi	r30, 0x81	; 129
 e52:	fe 4f       	sbci	r31, 0xFE	; 254
 e54:	10 82       	st	Z, r1

			//switch to the other buffer
			ctrl.buffer_out_num ^= 1;
 e56:	81 e0       	ldi	r24, 0x01	; 1
 e58:	28 27       	eor	r18, r24
 e5a:	20 93 7e 01 	sts	0x017E, r18

	}
 e5e:	08 95       	ret

00000e60 <rfm12_init>:
* puts the module into receive mode before returning.
*
* \note Please note that the transmit power and receive amplification values are currently hard coded.
* Have a look into rfm12_hw.h for possible settings.
*/
void rfm12_init(void) {
 e60:	cf 93       	push	r28
 e62:	df 93       	push	r29
	//initialize spi
#ifdef __PLATFORM_AVR__
	SS_RELEASE();
 e64:	2a 9a       	sbi	0x05, 2	; 5
	DDR_SS |= (1<<BIT_SS);
 e66:	22 9a       	sbi	0x04, 2	; 4
		return d;
	#endif
}

static void spi_init(void) {
	DDR_MOSI |= (_BV(BIT_MOSI));
 e68:	23 9a       	sbi	0x04, 3	; 4
	DDR_SCK  |= (_BV(BIT_SCK));
 e6a:	25 9a       	sbi	0x04, 5	; 4
	#if !(RFM12_SPI_SOFTWARE)
		PORT_SPI |= (_BV(BIT_SPI_SS));
 e6c:	2a 9a       	sbi	0x05, 2	; 5
		DDR_SPI  |= (_BV(BIT_SPI_SS));
 e6e:	22 9a       	sbi	0x04, 2	; 4
	#endif

	DDR_MISO &= ~(_BV(BIT_MISO));
 e70:	24 98       	cbi	0x04, 4	; 4

	#if !(RFM12_SPI_SOFTWARE)
		SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); //SPI Master, clk/16
 e72:	81 e5       	ldi	r24, 0x51	; 81
 e74:	8c bd       	out	0x2c, r24	; 44
	#endif

	//store the syncronization pattern to the transmission buffer
	//the sync pattern is used by the receiver to distinguish noise from real transmissions
	//the sync pattern is hardcoded into the receiver
	rf_tx_buffer.sync[0] = SYNC_MSB;
 e76:	8d e2       	ldi	r24, 0x2D	; 45
 e78:	80 93 c3 01 	sts	0x01C3, r24
	rf_tx_buffer.sync[1] = SYNC_LSB;
 e7c:	84 ed       	ldi	r24, 0xD4	; 212
 e7e:	80 93 c4 01 	sts	0x01C4, r24

	//if receive mode is not disabled (default)
	#if !(RFM12_TRANSMIT_ONLY)
		//init buffer pointers
		ctrl.buffer_in_num = 0;
 e82:	10 92 7d 01 	sts	0x017D, r1
		ctrl.buffer_out_num = 0;
 e86:	10 92 7e 01 	sts	0x017E, r1
 e8a:	c7 e5       	ldi	r28, 0x57	; 87
 e8c:	d2 e0       	ldi	r29, 0x02	; 2
	uint8_t x;

	#ifdef __PLATFORM_AVR__

		for (x = 0; x < ( sizeof(init_cmds) / 2) ; x++) {
			rfm12_data(pgm_read_word(&init_cmds[x]));
 e8e:	fe 01       	movw	r30, r28
 e90:	85 91       	lpm	r24, Z+
 e92:	94 91       	lpm	r25, Z+
 e94:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
 e98:	22 96       	adiw	r28, 0x02	; 2
	//write all the initialisation values to rfm12
	uint8_t x;

	#ifdef __PLATFORM_AVR__

		for (x = 0; x < ( sizeof(init_cmds) / 2) ; x++) {
 e9a:	82 e0       	ldi	r24, 0x02	; 2
 e9c:	cf 36       	cpi	r28, 0x6F	; 111
 e9e:	d8 07       	cpc	r29, r24
 ea0:	b1 f7       	brne	.-20     	; 0xe8e <rfm12_init+0x2e>
		adc_init();
	#endif

	//setup interrupt for falling edge trigger
#ifdef __PLATFORM_AVR__
	RFM12_INT_SETUP();
 ea2:	85 b7       	in	r24, 0x35	; 53
 ea4:	88 60       	ori	r24, 0x08	; 8
 ea6:	85 bf       	out	0x35, r24	; 53
#endif

	//clear int flag
	rfm12_read(RFM12_CMD_STATUS);
 ea8:	80 e0       	ldi	r24, 0x00	; 0
 eaa:	90 e0       	ldi	r25, 0x00	; 0
 eac:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <rfm12_read>

#ifdef __PLATFORM_AVR__
	RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 eb0:	82 e0       	ldi	r24, 0x02	; 2
 eb2:	8c bb       	out	0x1c, r24	; 28
#endif

	//init receiver fifo, we now begin receiving.
	rfm12_data(CLEAR_FIFO);
 eb4:	81 e8       	ldi	r24, 0x81	; 129
 eb6:	9a ec       	ldi	r25, 0xCA	; 202
 eb8:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>
	rfm12_data(ACCEPT_DATA);
 ebc:	83 e8       	ldi	r24, 0x83	; 131
 ebe:	9a ec       	ldi	r25, 0xCA	; 202
 ec0:	0e 94 d5 05 	call	0xbaa	; 0xbaa <rfm12_data>

	//activate the interrupt
	RFM12_INT_ON();
 ec4:	e9 9a       	sbi	0x1d, 1	; 29
}
 ec6:	df 91       	pop	r29
 ec8:	cf 91       	pop	r28
 eca:	08 95       	ret

00000ecc <rfm12_tx>:
	#if (RFM12_NORETURNS)
	void
	#else
	uint8_t
	#endif
	rfm12_tx(uint8_t len, uint8_t type, uint8_t *data) {
 ecc:	0f 93       	push	r16
 ece:	1f 93       	push	r17
 ed0:	18 2f       	mov	r17, r24
 ed2:	06 2f       	mov	r16, r22
		#if RFM12_UART_DEBUG
			uart_putstr ("sending packet\r\n");
		#endif

		if (len > RFM12_TX_BUFFER_SIZE) return TXRETURN(RFM12_TX_ERROR);
 ed4:	8f 31       	cpi	r24, 0x1F	; 31
 ed6:	10 f0       	brcs	.+4      	; 0xedc <rfm12_tx+0x10>
 ed8:	82 e0       	ldi	r24, 0x02	; 2
 eda:	12 c0       	rjmp	.+36     	; 0xf00 <rfm12_tx+0x34>

		//exit if the buffer isn't free
		if (ctrl.txstate != STATUS_FREE)
 edc:	80 91 7a 01 	lds	r24, 0x017A
 ee0:	88 23       	and	r24, r24
 ee2:	11 f0       	breq	.+4      	; 0xee8 <rfm12_tx+0x1c>
 ee4:	83 e0       	ldi	r24, 0x03	; 3
 ee6:	0c c0       	rjmp	.+24     	; 0xf00 <rfm12_tx+0x34>
			return TXRETURN(RFM12_TX_OCCUPIED);

		memcpy(rf_tx_buffer.buffer, data, len);
 ee8:	28 ec       	ldi	r18, 0xC8	; 200
 eea:	31 e0       	ldi	r19, 0x01	; 1
 eec:	c9 01       	movw	r24, r18
 eee:	ba 01       	movw	r22, r20
 ef0:	41 2f       	mov	r20, r17
 ef2:	50 e0       	ldi	r21, 0x00	; 0
 ef4:	0e 94 83 07 	call	0xf06	; 0xf06 <memcpy>

		#if (!(RFM12_NORETURNS))
		return rfm12_start_tx(type, len);
 ef8:	80 2f       	mov	r24, r16
 efa:	61 2f       	mov	r22, r17
 efc:	0e 94 06 07 	call	0xe0c	; 0xe0c <rfm12_start_tx>
		#else
		rfm12_start_tx(type, len);
		#endif
	}
 f00:	1f 91       	pop	r17
 f02:	0f 91       	pop	r16
 f04:	08 95       	ret

00000f06 <memcpy>:
 f06:	fb 01       	movw	r30, r22
 f08:	dc 01       	movw	r26, r24
 f0a:	02 c0       	rjmp	.+4      	; 0xf10 <memcpy+0xa>
 f0c:	01 90       	ld	r0, Z+
 f0e:	0d 92       	st	X+, r0
 f10:	41 50       	subi	r20, 0x01	; 1
 f12:	50 40       	sbci	r21, 0x00	; 0
 f14:	d8 f7       	brcc	.-10     	; 0xf0c <memcpy+0x6>
 f16:	08 95       	ret

00000f18 <_exit>:
 f18:	f8 94       	cli

00000f1a <__stop_program>:
 f1a:	ff cf       	rjmp	.-2      	; 0xf1a <__stop_program>
